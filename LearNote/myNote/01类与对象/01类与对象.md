# 成员属性封装

​		在类之中的组成就是属性与方法，一般而言方法都是对外提供服务的，所以是不会进行封装处理的，而对于属性来说，由于其需要较高的安全性，所以往往需要对其进行保护，这个时候就需要采用封装性对其保护。

​		在默认的情况下，对于类中的属性是可以通过其他类利用对象进行调用的。

**范例：**属性不封装情况下的问题

```java
public class ClassTest {   // 主类
	
	public static void main (String[] args) {
		Person per = new Person();//声明并实例化对象
		per.name = "张三";  // 在类外部修改属性
		per.age  = 23;  // 在类外部修改属性
		per.tell();//进行方法的调用
	}
}
```

​		此时在Person类中提供的name与age两个属性并没有进行封装处理，这样外部就可以直接进行调用了，但是有可能所设置的数据是错误的数据。如果要想解决这样的问题就可以利用Private关键字对属性进行封装处理。

**范例**:对属性进行封装

```java
public class Person {
	private String name;
	private int age;
	public String tell() {
		System.out.println("姓名:"+ name + "\n年龄：" + age);
		return "姓名:"+ name + "\n年龄：" + age;
	}

```

​		而属性一旦封装完成，将对外部不可见；即：外部不能直接访问，但是对类内部是可见，那么如果要想让外部的程序想要访问封装属性，则在Java开发标准中提供有如下要求：

- ​		【setter、getter】设置或取得属性可以使用setXxx()、getXxx()方法，以：private String name;为例
  			- 设置属性方法：public void setName(String n);
  			- 获取属性方法：public String getName();

**范例**：实现封装

```java
public class Person {
	private String name;
	private int age;
	public String tell() {
		System.out.println("姓名:"+ name + "\n年龄：" + age);
		return "姓名:"+ name + "\n年龄：" + age;
	}
	public void setName(String n) {
		name = n;
	}
	public void setAge(int a) {
		if (a > 0) {
			age = a;
		}
	}
	public String getName() {
		return name;
	}
	public int getAge() {
		return age;
	}
public static void main (String[] args) {
		Person per = new Person();//声明并实例化对象
		per.setName("张三");  // 在类外部修改属性
		per.setAge(-18);  // 在类外部修改属性
		per.tell();//进行方法的调用
	}
```

​		在以后进行任何类定义的时候一定要记住，类中所有属性都必须使用private封装（98%），并且

属性如果要进行访问必须提供setter与getter方法。# 对象实例化操作初步分析

​		JAVA之中类属于引用数据类型，引用数据类型最大的困难之有处在于要进行内存的管理，同时在进行操作的时候也会发生有内存关系的变化，所以本次针对于之前的程序内存关系进行一些简单的分析。

**范例**：以下面的程序为主进行分析

```java
package com.kgc.classd;

public class ClassTest {
	
	public static void main (String[] args) {
		Person zsPerson = new Person();//声明并实例化对象
		zsPerson.name = "张三";
		zsPerson.age  = 23;
		zsPerson.tell();//进行方法的调用
	}
}

```

​		如果要进行内存分析，那么首先给出两块最为常用的内存空间：

- ​		堆内存：保存的是对象的具体信息，在程序之中堆内存空间的开辟是通过new关键字完成的。
- ​		栈内存：保存的是一块堆内存的地址，即：通过地址找到堆内存，而后找到对象内容，但是为了分析简单起见，可以简单地理解为：对象名称保存在了栈内存之中

### 堆栈模型

![image-20210329090444032](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329090444032.png)

### 内存分析

![image-20210329091339610](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329091339610.png)

对象的实例化有两种语法，一种是使用之前的声明并实例化对象，另一种就是分步完成，所以下面针对于分布的内存操作进行分析。

**范例：定义程序代码**

```java
public class ClassTest {
	public static void main (String[] args) {
		Person per = null;  // 声明对象
		per = new Person(); // 实例化对象
		per.name = "张三";
		per.age  = 23;
		per.tell();//进行方法的调用
	}
}

```

​		下面通过内存分析来进行解释。。

![image-20210329093417424](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329093417424.png)

​		需要特别引起注意的是，所有的对象在调用类中的属性或方法的时候必须要实例化完成。

**范例**：错误的代码

```java
public class ClassTest {
	public static void main (String[] args) {
		Person per = null;  // 声明对象
        //未实例化对象
		per.name = "张三";
		per.age  = 23;
		per.tell();//进行方法的调用
	}
}

```

# 代码块

​		在程序之中使用 “{ }” 定义的结构就称为代码块，而后根据代码块出现的位置以及定义的关键字的不同，代码块可以分为：普通代码块、构造块、静态块、同步代码块，其中对于同步代码块是在多线程的时候才会进行讲解。

## 普通代码块

​		普通代码块的主要特点是定义在一个方法之中的代码块。

**范例：观察一个程序**

```java
public class JavaDemo{
    public static void main(String[] args){
        if(true){ // 条件一定满足
            int x = 10;  // 局部变量
            System.out.println("x = " + x);
        }
        int x = 100;  //  全局变量
        System.out.println("x = " + x);
    }
}
```

​		按照Java程序的开发标准规定相同名称的变量是不能够在同一个方法之中存在的，但是由于此时有不同的分界描述。但如果说要定义普通代码块，那么只需要将当前的if语句取消即可。

```java
public class JavaDemo{
    public static void main(String[] args){
        { // 普通代码块
            int x = 10;  // 局部变量
            System.out.println("x = " + x);
        }
        int x = 100;  //  全局变量
        System.out.println("x = " + x);
    }
}
```

 		可以在一个方法之中进行一些结构的拆分，以防止相同变量名称所带来的互相影响。

## 构造代码块

​		 构造块是定义在一个类之中的

**范例：**观察构造块

```java
class Person01{
	public Person01() {
		System.out.println("【构造方法】Person类构造方法执行");
	}
	{
		System.out.println("【构造块】Person构造块执行");
	}
}

public class JavaDemo01 {

	public static void main(String[] args){
        new Person01();
        new Person01();
        new Person01();
    }

}
```

## 静态代码块

​		静态代码块主要指的是使用static关键字定义的代码块，静态块的定义需要考虑到两种情况：主类中定义静态块、非主类中定义静态块。

**范例：**在非主类中进行静态块的定义

```java
class Person01{
	public Person01() {
		System.out.println("【构造方法】Person类构造方法执行");
	}
	static{
		System.out.println("【静态块】静态块执行。");
		
	}
	{
		System.out.println("【构造块】Person构造块执行");
	}
}

public class JavaDemo01 {

	public static void main(String[] args){
        new Person01();
    }
}
```

​		此时可以发现静态代码块会优先于构造块执行，并且不管有多少个实例化对象出现静态代码块只会执行一次，静态代码块的主要目的是为类中的静态属性初始化。

**范例：**观察静态属性初始化



```java
class Message {
    public static String getCountry(){
        //该消息的内容可能来自于网络或者其他服务器
        return "中华人民共和国" ;
    }
}
class Person {
    private static String country ;
    static {
        // 可能有很多语句要执行
        country = Message.getCountry();
        System.out.println(country) ; 
    }
}
public class JavaDemo {
    public static void main(String arg[]){
        new Person();   
    }
}
```

​		对于静态代码块还必须考虑另一种情况，在主类中定义的形式。

**范例：**在主类中进行静态代码块的定义

```java
public class JavaDemo {
    static {
        System.out.println("******* 程序初始化 ********") ;
    }
    public static void main(String arg[]){
        System.out.println("主方法输出");
    }
}
```

​		静态代码块优先于主方法先执行。

```java
package org.jgs.pratice;

public class Address {
	private String country;
	private String province;
	private String city;
	private String street;
	private String postcode;
	public Address () {}  // 无参构造
	public Address (String country,String province,String city,String street,String postcode) {
		this.country = country;												// 有参构造
		this.province = province;
		this.city = city;
		this.street = street;
		this.postcode = postcode;
	}
	public void setCountry(String country) {
		this.country = country;
	}
	public void setProvince(String province) {
		this.province = province;
	}
	public void setCity(String city) {
		this.city = city;
	}
	public void setStreet(String street) {
		this.street = street;
	}
	public void setPostcode(String postcode) {
		this.postcode = postcode;
	}
	public String getCountry() {
		return country;
	}
	public String getProvince() {
		return province;
	}
	public String getCity() {
		return city;
	}
	public String getStreet() {
		return street;
	}
	public String getPostcode() {
		return postcode;
	}
	public String getInfo() {
		
		return this.country + "" + this.province + "省" + this.city + "市" + this.street +
				"(街/道)" + this.postcode;

	}
	
}

```

#  案例分析二

​		定义并测试一个代表员工的Employee类。员工属性包括“编号”、“姓名”、“基本薪水”、“薪水增长率”，还包括计算薪水增长额及计算增长后的工资总额的操作方法。

​		这个程序的功能已经超过了简单Java类的定义范畴，因为简单Java类里面不需要涉及到复杂的计算逻辑，但是设计的思考是应该从简单java类开始。

```java

/**
 * @Description
 *  案例分析二
 * 		定义并测试一个代表员工的Employee类。员工
 * 属性包括“编号”、“姓名”、“基本薪水”、“薪水增长
 * 率”，还包括计算薪水增长额及计算增长后的工资总额
 * 的操作方法。
 * @author AlexYU Email:alex2354629991@gmail.com
 * @version
 * @date 2021年4月6日下午5:02:04
 */
public class Employee {
	private long code;
	private String name;	
	private double salary;
	private double rate;
	public Employee () {}
	public Employee (long code,String name,double salary,double rate) {
		this.code = code;
		this.name = name;
		this.salary = salary;
		this.rate = rate;
	}
	// 得到薪水增长额度
	public double salaryIncValue() {
		return this.salary * this.rate ;
	}
	// 计算薪水增长总额
	public double salaryIncResult() {
		
		this.salary = this.salary + this.salaryIncValue();
		
		return this.salary ;
	}
	public String getInfo() {
		return "编号:" + this.code + "、姓名:" + name + "、基本薪水:" + salary + "、薪水增长率:" + rate;
	// setter、getter略
	}
}

```

# 案例分析三

设计一个Dog类，有名字、颜色、年龄等属性，定义构造方法来初始化类的这些属性，定义构造方法来初始化类的这些属性，定义方法输出Dog信息，编写应用程序使用Dog类。

```java
/**
 * @Description
 * 		设计一个Dog类，有名字、颜色、年龄等属
 * 性，定义构造方法来初始化类的这些属性，定义构造方法
 * 来初始化类的这些属性，定义方法输出Dog信息，编写应用
 * 程序使用Dog类。
 * @author AlexYU Email:alex2354629991@gmail.com
 * @version
 * @date 2021年4月6日下午6:40:17
 */
public class Dog {
	private String name;
	private String color;
	private int age;
	public Dog() {}
	public Dog(String name,String color,int age) {
		this.age = age;
		this.name = name;
		this.color = color;
	}
	// setter、getter略
	public String getInfo() {
		return "名字是："+name+"\n毛色："+color+"\n年龄："+age;
	}
}

```

# 案例分析四

​		构造一个银行账户类，类的构成包括如下内容：

（1）、数据成员用户的账户名称、用户的账户余额（private数据类型）。
（2）、方法包括开户（设置账户名称及余额），利用构造方法完成。
（3）、查询余额。

```java
public class Account {
	private String name;
	private double balence;
	public Account() {}
	public Account(String name) {
		this(name,0.0);  // 调用双参构造
	}
	public Account(String name,double balence) {
		this.name = name;
		this.balence = balence;
	}
	public double getBalence() {
		return balence;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public void setBalence(double balence) {
		this.balence = balence;
	}
	public String getInfo() {
		return "账户名称：" + this.name + "\n账户余额：" + this.balence;

	}
}

```

# 案例分析五

​		设计一个表示用户的User类，类中的变量有用户名、口令和记录用户个数的变量，定义类的3个构造方法（无参、为用户名赋值、为用户名和口令赋值）、获取和设置口令的方法和返回类信息的方法。

```java
class User {
    private String uid;
    private String password;
    private static int count = 0;
    public User(){
        this("NOID","bdqn");
    }
    public User(String uid){
        this(uid,"jgs2111");
    }
    public User(Strong uid,String password){
        this.uid = uid;
        this.password = password;
        count ++ ; // 个数追加
    }
    // setter、getter略
    public static int getCount(){ //  获得用户个数
        return count;
        
    }
    public String getInfo() {
        return "用户名："+uid+"\n密码："+password;
    }
}
```

# 案例分析六

​		声明了个图书类，其数据成员为书名、编号（利用静态变量实现自动编号）、书价，并拥有静态数据成员册数、记录图书册数，在构造方法中利用此静态变量为对象的编号赋值，在主方法中定义多个对象，并求出总册数。

```java

/**
 * @Description 案例分析六
 * 声明了个图书类，其数据成员为书名、编号（利用静态变量实现自动编号）、
 * 书价，并拥有静态数据成员册数、记录图书册数，在构造方法中利
 * 用此静态变量为对象的编号赋值，在主方法中定义多个对象，并求出总册数。
 * @author AlexYU Email:alex2354629991@gmail.com
 * @version
 * @date 2021年4月6日下午7:40:25
 */
public class Book{
    private int bid;  // 编号
    private String title;  // 书名
    private static int count = 0;
    private double price;  // 价格
    public Book(String title,double price){
        this.bid = ++ count ;  // 先赋值再自增
        this.title = title;
        this.price = price;
    }
    // setter、getter略
    public String getInfo(){
        return "编号："+this.bid+"\t书名："+title+"\t价格："+price;
    }
    public static int getCount() {
    	return count;
    }
}
public class JavaDemo {
    
    public static void main(String arg[]){
    	Book b1 = new Book("javascript", 10.90);
    	Book b2 = new Book("java", 156.2220);
    	Book b3 = new Book("typescript", 18.90);
    	System.out.println(b1.getInfo());
    	System.out.println(b2.getInfo());
    	System.out.println(b3.getInfo());
    	System.out.println(Book.getCount());
    }
}
```

​		在面向对象最基础的开发里面，简单Java类是解决先期设计最好的方案。
# 引用传递分析

​		

类本身属于引用数据类型，既然是引用数据类型，那么就牵扯到内存的引用传递，所谓的内存的引用传递就是同一块堆内存的空间可以被不同的栈内存所指向，也可以更换指向。。

**范例**：定义一个引用传递的分析程序。

```java
public class ClassTest {
	
	public static void main (String[] args) {
		Person per1 = new Person();//声明并实例化对象
		per1.name = "张三";
		per1.age  = 23;
		Person per2 = per1;  // 引用传递
		per2.age = 80;
		per1.tell();//进行方法的调用
	}
}
```

![image-20210329100756247](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329100756247.png)

​		这个时候的引用传递是直接在主方法之中定义的，也可以通过方法实现引用传递处理。

**范例**：利用方法实现引用传递

```java
public class ClassTest {
	
	public static void main (String[] args) {
		Person per = new Person();//声明并实例化对象
		per.name = "张三";
		per.age  = 23;
		change(per);// 等价于：Person temp = per ;
		per.tell();//进行方法的调用
	}
	
	public static void change(Person temp) {
		temp.age = 70;
	}
	
}
运行结果：
姓名:张三
年龄：70
```

与之前最大的区别就是，此时的程序是将Person类的实例化对象（内存地址、数值）传递到了change（）方法之中，由于传递的是一个Person类型，那么change（）方法接收的也是Person类型。

#### 内存分析

##### ![image-20210329103520841](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329103520841.png)

​		引用传递可以发生在方法上，这个时候一定要观察方法的参数类型，同时也要观察方法的执行过程。

# 引用传递与垃圾产生分析

​		经过了一系列的分析之后已经确认，所有的引用传递的本质就是一场堆内存的调戏游戏。

但是对于引用传递如果处理不当那么也会造成垃圾的产生，那么本次将针对于垃圾产生原因

进行简单分析。

范例：定义一个要分析的程序

```java
public static void main (String[] args) {
		Person per1 = new Person();//声明并实例化对象
		Person per2 = new Person();//声明并实例化对象
		per1.name = "张三";
		per1.age  = 23;
		per2.name = "李四";
		per2.age  = 26;
		
		per2 = per1;  // 引用传递
		per2.age = 80;
		per1.tell();//进行方法的调用
	}
```

此时明确的发生了引用传递，并且也成功的完成了引用传递的处理操作，但是下面来观察一下其

内存的分配与处理流程。

*一个栈内存只能够保存有一个堆内存的地址数据，如果发生更改，则之前的地址数据将从此栈内存中彻底消失。*

![image-20210329105503299](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329105503299.png)

​		所谓的垃圾空间指的就是没有任何栈内存所指向的堆内存空间，所有的垃圾将被GC（GarbageCollector、垃圾收集器）不定期进行回收并且释放无用内存空间，但是如果垃圾过多，一定将影响到GC的处理性能，从而降低整体的程序性能，那么在实际开发中，对于垃圾的产生越少越好。# 构造方法与匿名对象

​		现在的程序在使用类的时候一般都按照如下的步骤进行：

- ​	声明并实例化对象，这个时候实例化对象中的属性并没有任何的数据存在，都是其对应数据类型的默认值；
-    ​    需要通过一系列的setter方法为类中的属性设置内容。

  等于现在要想真正获得一个可以正常使用的实例化对象，必须经过两个步骤才可以完成。

#### **范例：传统调用**

```java
public class Person {
	private String name;
	private int age;
	public String tell() {
		System.out.println("姓名:"+ name + "\n年龄：" + age);
		return "姓名:"+ name + "\n年龄：" + age;
	}
	public void setName(String n) {
		name = n;
	}
	public void setAge(int a) {
		
		age = a;
	
	}
	public String getName() {
		return name;
	}
	public int getAge() {
		return age;
	}
}
public class ClassTest {   // 主类
	
	public static void main (String[] args) {
		//1、对象初始化准备
		Person per = new Person();//声明并实例化对象
		per.setName("张三");  // 在类外部修改属性
		per.setAge(-18);  // 在类外部修改属性
		//2、对象的使用
		per.tell();//进行方法的调用
	}
}
```

	new Student()  类名()  Student() 构造方法  特殊方法 用于创建对象
1.如果类中没有显示定义构造方法 虚拟机会帮我们自动提供一个无参的构造方法

2.如果类中有定义构造方法 虚拟机不在提供一个无参的构造方法

普通方法：

权限修饰符 返回值 方法名(参数列表){}



构造方法：

权限修饰符(public) 方法名(参数列表){方法体}

1.没有返回值  不要写void

2.构造方法名必须和类名保持一致

3.构造方法用于创建对象   使用关键字new 来调用

4.构造方法也是可以重载的

5.构造方法之间可以互相调用 使用this() 但是要保证this() 要在第一行

6.构造方法可以调用普通的方法 反之不行

但是如果按照这样的方式来进行思考就会发现一个问题：假设说现在类中的属性很多个（8个），按照以前的做法，此时就需要调用8次setter方法进行内容设置。这样的调用实在是太啰嗦了，所以在Java里面为了考虑到对象初始化的问题，专门提供有构造方法，即：**可以通过构造方法实现实例化对象中属性初始化处理**。只有在关键字new的时候使用构造方法，在Java程序里面构造方法的定义要求如下：

- ​	构造方法名称必须与类名保持一致；
- ​    构造方法不允许设置任何的返回值类型，即：没有返回值定义；
- ​    构造方法是在使用关键子new实例化对象的时候自动调用的。

#### **范例：定义构造方法**

```java
public class Person {
	private String name;
	private int age;
	// 方法名称与类名相同，并且无返回值定义
	public Person(String n,int a) { // 定义有参构造
		name = n; // 为类中的属性赋值（初始化）
		age = a;  // 为类中的属性赋值（初始化）
	}
	public String tell() {
		System.out.println("姓名:"+ name + "\n年龄：" + age);
		return "姓名:"+ name + "\n年龄：" + age;
	}
}
public class ClassTest {   // 主类
	
	public static void main (String[] args) {
		//1、对象初始化准备
		Person per = new Person("张三",16);//声明并实例化对象
		//2、对象的使用
		per.tell();//进行方法的调用
	}
}
```

下面针对于当前与之前的实例化格式做一个比较：

- 之前的实例化格式：

  ```
  ①Person ②per = ③new ④Person();//声明并实例化对象
  ```

- 当前的实例化格式：

  ```
  ①Person ②per = ③new ④Person("张三",16);//声明并实例化对象
  ```

  “①Person”：主要是定义对象的所属类型，类型决定了可以调用的方法

  “②per”      ：实例化对象的名称，所有的操作通过对象来进行访问；

  “③new”    ：开辟一块新的堆内存空间；

  “④Person("张三",16)”：调用有参构造、“④Person()”调用无参构造；

  ​		在Java程序里面考虑到程序结构的完整性，所以所有的类都会提供有构造方法，也就是说如果现在你的类中没有定义任何的构造方法，那么一定会默认提供一个无参的，什么都不做的构造方法，这个构造方法是在程序编译的时候自动创建的。如果你现在已经在类中明确的定义有一个构造方法的时候，那么这个默认的构造方法将不会被自动创建。

  ​		**结论：一个类至少存在有一个构造方法，永恒存在。**

**疑问：为什么构造方法上不允许设置返回类型？**

​		*既然构造方法是一个方法，那么为什么不让它定义返回值类型呢？*

​		*既然构造方法不会返回数据，为什么不使用void定义呢？*

分析：程序编译器是根据代码结构来进行编译处理的，执行的时候也是根据代码结构来处理的。*如果在构造方法上使用了void，那么此结构就与普通方法结构完全相同了，这样编译器会认为此方法是一个普通方法，普通方法与构造方法最大的区别：构造方法是在类对象实例化的时候调用的，而普通方法是在类对象实例化产生之后调用的。*

既然构造方法本身是一个方法，那么方法就具有重载的特点，而构造方法重载的时候只需要考虑参数的类型及个数即可。

#### **范例：**构造方法重载

```java
public class Person {
	private String name;
	private int age;
	public Person() {
		name = "无名氏";
		age = -1;
	};
	public Person(String n) {
		name = n;
	};
	// 方法名称与类名相同，并且无返回值定义
	public Person(String n,int a) { // 定义有参构造
		name = n; // 为类中的属性赋值（初始化）
		age = a;  // 为类中的属性赋值（初始化）
	}
	public String tell() {
		System.out.println("姓名:"+ name + "\n年龄：" + age);
		return "姓名:"+ name + "\n年龄：" + age;
	}
}
public class ClassTest {   // 主类	
	public static void main (String[] args) {
		//1、对象初始化准备
		Person per = new Person();//声明并实例化对象
		//2、对象的使用
		per.tell();//进行方法的调用
	}
}
```

​		在进行多个构造方法定义的时候强烈建议大家一些定义的顺序,例如: 可以按照**参数的个数降序或升序排列**。经过分析可以发现,构造方法的确是可以行数据的设置,而对于setter也可以进行数据的设置，这个时候一定要清楚，构造方法是在对象实例化的时候为属性设置初始化内容,而 setter除了拥有设置数据的功能之外,还具有修改数据的功能。

#### 范例:使用 setter修改数据

```java
public class Person {
	private String name;
	private int age;

	public Person() {
		name = "无名氏";
		age = -1;
	};

	public Person(String n) {
		name = n;
	};

	// 方法名称与类名相同，并且无返回值定义
	public Person(String n, int a) { // 定义有参构造
		name = n; // 为类中的属性赋值（初始化）
		age = a; // 为类中的属性赋值（初始化）
	}
	public String tell() {
		System.out.println("姓名:" + name + "\n年龄：" + age);
		return "姓名:" + name + "\n年龄：" + age;
	}
	public void setName(String n) {
		name = n;
	}
	public void setAge(int a) {
		age = a;
	}
	public String getName() {
		return name;
	}
	public int getAge() {
		return age;
	}
}
public class ClassTest {   // 主类
	
	public static void main (String[] args) {
		//1、对象初始化准备
		Person per = new Person("张三",98);//声明并实例化对象
		//2、对象的使用
		per.setAge(18);
		per.tell();//进行方法的调用
	}
}

```

​		经过了分析之后可以发现,利用构造方法可以传递属性数据,于是现在进一步分析对象的产生格式：

- 定义对象的名称:  类名称对象名称=nul 
- 实例化对象:        对象名称new类名称()

如果这个时候只是通过实例化对象来进行类的作也是可以的,而这种形式的对象由于没有名字就称为匿名对象.

#### 范例:  观察匿名对象

```java
public class ClassTest {   // 主类
	public static void main (String[] args) {
		new Person("张三",98).tell();//进行方法的调用
	}
}
```

​		此时依然通过了对象进行了类中tel方法的调用,但是由于此对象没有任何的引用名称,所以该对象使用一次之后就将成为垃圾,而所有的垃圾将被GC进行回收与释放。

​		现在发现此时的程序里面已经存在有构造方法了,那么下面通过一个程序来利用构造方法进行一次内存分析.

#### 范例:  编写一个分析程序

```java
package com.kgc.classd;

class Message{
	private String title;
	public Message(String t){
		title = t;
	}
	public String getTitle(){
		return title;
	}
	public void setTitle(String t){ // 具有修改功能
		title = t;
	}
}
class Person {
	private String name;
	private int age;
	// 方法名称与类名相同，并且无返回值定义
	public Person(Message msg, int a) { // 定义有参构造
		name = msg.getTitle(); // 为类中的属性赋值（初始化）
		age = a; // 为类中的属性赋值（初始化）
	}
	public Message getInfo() {
		return new Message(name + ":" + age);
	}
	public String tell() {
		System.out.println("姓名:" + name + "\n年龄：" + age);
		return "姓名:" + name + "\n年龄:" + age;
	}
}
public class JavaClassTest {   // 主类
	
	public static void main (String[] args) {
		Message msg = new Message("mlkj");
		Person Person = new Person(msg,20);
		msg = Person.getInfo();
		System.out.println(msg.getTitle());
	}
}
```

下面通过此程序进行一个简短的内存分析。.

![image-20210330095522637](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210330095522637.png)

​		只要是方法都可以传递任意的数据类型（基本数据类型、引用数据类型）。
# this关键字

this可以算是Java里面比较复杂的关键字，因为this的使用形式上决定了它的灵活性。在程序里面，使用this可以实现三类结构的描述：.

- ```
  当前类中的属性：this.属性；
  ```

- ```
  当前类中的方法（普通方法、构造方法）：this（）、this.方法名称（）；
  ```

- ```
  描述当前对象；
  ```

## 使用this 调用当前类中属性。

 		通过现在的分析可以发现，利用构造方法或者是setter方法都可以进行类中的属性的赋值，但是在进行赋值的时候，之前采用的是如下定义形式：

```java
class Person {
	private String name;
	private int age;
	// 方法名称与类名相同，并且无返回值定义
	public Person(String n,int a) {
		name = n;
		age = a;
	}
	public void tell() {
		System.out.println("姓名："+ name + "\n年龄：" + age);
	}
	// setter、getter略 
}
public class JavaClassTest {   // 主类
	
	public static void main (String[] args) {
		Person person = new Person("王五", 38);
		person.tell();
	}
}
```

​		但是这个时候在构造方法定义的过程之中会发现有一点点的问题：

```java
public Person(String n,int a) {
		name = n;
		age = a;
	}
```

​		这个问题出现在参数名称上，可以发现，此时构造方法中两个参数的目的是为了类中的name或age属性初始化，但是现在却发现此时的代码n和a参数名称不好。

​		如果说现在将构造方法中的参数名称修改为name、age，则发现无法进行属性的正确设置：

​		

```java
public Person(String n,int a) {
		name = name;
		age = age;
	}
```

在Java程序之中“{}”是作为一个结构体的边界符，那么在程序里面当进行变量（参数、属性都称为变量）使用的时候都会以“{}”作为一个查找边界，所以按照就近取用的原则，此时的构造方法并没有能够访问类中的属性，所以此时为了明确的标记出类中的属性与参数的区别，往往会在属性前追加一个“this”，表示本类属性。

```java
class Person {
	private String name;
	private int age;
	// 方法名称与类名相同，并且无返回值定义
	public Person(String name,int age) {
		this.name = name;
		this.age = age;
	}
	public void tell() {
		System.out.println("姓名："+ this.name + "\n年龄：" + this.age);
	}
	// setter、getter略 
}
```

​		在你以后所编写的程序代码之中，只要是访问本类中属性的时候，请一定要加上“this”# 使用this调用方法

​		除了调用属性之外，this也可以实现方法的调用，但是对于方法的调用就必须考虑构造与普通方法：

- 构造方法调用（this（））：使用关键字new实例化对象的时候才会调用构造方法；

- 普通方法调用（this.方法名称（））：实例化对象产生之后就可以调用普通方法。

## 范例：调用类中的普通方法

```java
class Person {
	private String name;
	private int age;
	// 方法名称与类名相同，并且无返回值定义
	public Person(String name,int age) {
		this.setName(name);
		setAge(age);// 加与不加都表示本类 
	}
	public void tell() {
		System.out.println("姓名："+ this.name + "\n年龄：" + this.age);
	}
	public void setName(String name) {
		this.name = name;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public String getName() {
		return this.name;
	}
	public int getAge() {
		return this.age;
	}
}
public class JavaClassTest {   // 主类
	
	public static void main (String[] args) {
		Person person = new Person("王五", 38);
		person.tell();
	}
}
```

​		除了普通的方法调用之外，还需要进行构造方法的调用，对于构造方法的调用，肯定是要放在构造方法中执行。现在假设说类中一共定义有三个构造方法，但是要求不管调用那个构造方法，都执行一行输出语句“一个新的Person类对象实例化”。

> | 传统方法                                                     | 利用this（）构造调用优化：                                   |
> | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | class Person {<br/>	private String name;<br/>	private int age;<br/>	// 方法名称与类名相同，并且无返回值定义<br/>	public Person() {<br/>		System.out.println("***一个新的Person类对象实例化。");<br/>	}<br/>	public Person(String name) {<br/>		this.name = name;<br/>		System.out.println("***一个新的Person类对象实例化。");<br/>	}<br/>	public Person(String name,int age) {<br/>		this.name = name;<br/>		this.age = age;<br/>		System.out.println("***一个新的Person类对象实例化。");<br/>	}<br/>	public void tell() {<br/>		System.out.println("姓名："+ this.name + "\n年龄：" + this.age);<br/>	}<br/>	// setter、getter略<br/>}<br/>public class JavaClassTest {   // 主类<br/>	<br/>	public static void main (String[] args) {<br/>		Person person = new Person();<br/>		person.tell();<br/>	}<br/>} | class Person {<br/>	private String name;<br/>	private int age;<br/>	// 方法名称与类名相同，并且无返回值定义<br/>	public Person() {<br/>		System.out.println("***一个新的Person类对象实例化。");<br/>	}<br/>	public Person(String name) {<br/>		**this();**    //  调用本类无参构造<br/>		this.name = name;<br/>	}<br/>	public Person(String name,int age) {<br/>		this(name);    //  调用本类单参构造<br/>		this.age = age;<br/>	}<br/>	public void tell() {<br/>		System.out.println("姓名："+ this.name + "\n年龄：" + this.age);<br/>	}<br/>	// setter、getter略<br/>}<br/>public class JavaClassTest {   // 主类<br/>	<br/>	public static void main (String[] args) {<br/>		Person person = new Person("李峰",67);<br/>		person.tell();<br/>	}<br/>} |

如果要想评价一个代码的好坏：

- ​	代码结构可以重用，提供的是一个中间独立的支持；

- ​    我们的目标是：没有重复；

对于本类构造方法的互相调用需要注意以下几点重要问题：.

- **构造方法必须在实例化新对象的时候调用，所以“this（）”的语句只允许放在构造方法的首行；**

- **构造方法互相调用时请保留有程序的出口，别形成死循环；**

```java
class Person {
	private String name;
	private int age;
	// 方法名称与类名相同，并且无返回值定义
	public Person() {
		this("你的眼",88);
		System.out.println("***一个新的Person类对象实例化。");
	}
	public Person(String name) {
		this();    //  调用本类无参构造
		this.name = name;
	}
	public Person(String name,int age) {
		this(name);    //  调用本类单参构造
		this.age = age;
	}
	public void tell() {
		System.out.println("姓名："+ this.name + "\n年龄：" + this.age);
	}
	// setter、getter略
}
public class JavaClassTest {   // 主类
	
	public static void main (String[] args) {
		Person person = new Person("李峰",67);
		person.tell();
	}
}
```

​		此时的程序在进行编译的时候将会直接出现错误提示：告诉用户，你出现了构造方法的递归调用。

**构造方法互调用案例：**

​		现在要求定义一个描述有员工信息的程序类，该类中提供有：编号、姓名、部门、工资，在这个类之中提供有四个构造方法。

1. 【无参构造】编号定义为1000，姓名定义为无名氏；
2. 【单参构造】传递编号，姓名定义为“新员工”，部门定义为“未定”，工资为0；
3. 【三参构造】传递编号、姓名、部门，工资为2500.00；
4. 【四参构造】所有的属性全部进行传递。.

**范例：**进行代码的初期实现

```java
class Emp{
	private long empno;    //  员工编号
	private String ename;  //  员工姓名
	private String dept;   //  部门名称
	private double salary; //  基本工资
	public Emp() {
		this.empno = 1000;
		this.ename = "无名氏";
	}
	public Emp(long empno) {
		this.empno = empno;
		this.ename = "未定";
	}
	public Emp(long empno,String ename,String dept) {
		this.empno = empno;
		this.ename = ename;
		this.dept  = dept;
		this.salary= 2500.00;
	}
	public Emp(long empno,String ename,String dept,double salary) {
		this.empno = empno;
		this.ename = ename;
		this.dept  = dept;
		this.salary= salary;
	}
	//setter、getter略
	public String getInfo() {
		return "雇员编号： " + this.empno + 
			   "\t雇员姓名： " + this.ename + 
			   "\t所在部门： " + this.dept  + 
			   "\t基本工资： " + this.salary;
	}
}
public class ConstructionMethod {

	public static void main(String[] args) {
		Emp emp = new Emp(9527L,"史密斯","财政部",6500.00);
		System.out.println(emp.getInfo());
	}
}
```

​		此时可以发现代码有重复，所以就可以对Emp类进行简化定义。

```java
class Emp{
	private long empno;    //  员工编号
	private String ename;  //  员工姓名
	private String dept;   //  部门名称
	private double salary; //  基本工资
	public Emp() {
		this(9527L,"无名氏",null,0.0);
	}
	public Emp(long empno) {
		this(empno,"未定",null,0.0);
	}
	public Emp(long empno,String ename,String dept) {
		this(empno,ename,dept,2500.00);
	}
	public Emp(long empno,String ename,String dept,double salary) {
		this.empno = empno;
		this.ename = ename;
		this.dept  = dept;
		this.salary= salary;
	}
	//setter、getter略
	public String getInfo() {
		return "雇员编号： " + this.empno + 
			   "\t雇员姓名： " + this.ename + 
			   "\t所在部门： " + this.dept  + 
			   "\t基本工资： " + this.salary;
	}
}
public class ConstructionMethod {

	public static void main(String[] args) {
		Emp emp = new Emp(9527L,"史密斯","财政部");
		System.out.println(emp.getInfo());
	}

}
```

​		代码的任何位置上都可能有重复，所以消除重复的代码是先期学习之中最需要考虑的。











































# 综合实战: 简单Java类

​		在以后进行项目的开发与设计的过程之中，简单Java类都将作为一个重要的组成部分存在，慢慢接触到正规的项目设计之后，简单Java类无处不在，并且有可能会产生一系列的变化。

​		所谓的简单java类指的是可以描述某一类信息的程序类，例如：描述一个人、描述一本书、描述一个部门、描述一个雇员。并且在这个类之中并没有特别复杂的逻辑操作，只作为一种信息存储的媒介存在。

​		对于简单Java类而言，其核心的开发结构如下：

- 类名称一定要有意义，可以明确的描述某一类事物；

- 类之中的所有属性都必须使用private进行封装，同时封装后的属性必须要提供有setter、getter方法；
- 类之中可以提供有无数多个构造方法，但是必须要保留有无参构造方法；

- 类之中不允许出现任何的输出语句，所有内容的获取必须返回；

- 【非必须】可以提供有一个获取对象详细信息的方法，暂时将此方法名称定义为getInfo（）；

**范例：**定义一个简单java类。

```java
class Dept{		// 类名称可以明确描述出某类事物
    private long deptno ;
    private String dname ; 
    private String loc ;
    public Dept(){};     // 必须提供有无参
    public Dept(long deptno,String dname,String loc){
        this.deptno = deptno;
        this.dname = dname;
        this.loc = loc;
    }
    public String getInfo(){
        return "【部门信息】部门编号：" + this.deptno + "、部门名称：" + this.dname + "、部门位置" + this.loc ; 
    }
    public void setDeptno(long deptno) {
        this.deptno = deptno;
    }
    public void setDname(String dname){
        this.dname = dname;
    }
    public void setLoc(String loc){
        this.loc = loc;
    }
    public void getDeptno(){
        return this.deptno;
    }
    public void getDname(){
        return this.dname;
    }
    public void getLoc(){
        return this.loc;
    }  
}
public class JavaClassTest01 {
	
	public static void main(String[] args) {
		Dept dept = new Dept(10,"技术部","北京");
		System.out.println(dept.getInfo());
	}
}
```

​		这种简单Java类基本上就融合了所有的现在接触到的概念，例如：数据类型划分、类的定义、private封装、构造方法、方法定义对象实例化。# 声明static属性

​		static是一个关键字，这个关键字主要可以用来定义属性和方法。下面将针对于此关键字分析。

**static定义属性**

在一个类之中，所有的属性一旦定义了实际上内容都交由各自的堆内存空间所保存。

**范例：**定义一个程序类,观察传统操作的问题

```java
class Person {  //  创建所有同一个国家的类
    private String name ;
    private int age ;
    String country = "中华民国" ;    //  国家， 暂时不封装
    public Person(String name,int age) {
        this.name = name;
        this.age = age;
    }
    // setter、getter略
    public String getInfo() {
        return "姓名：" + this.name + "、年龄" + this.age + "、国家: " + this.country;
    }
}
public class JavaClassTest02 {
	
	public static void main(String[] args) {
		Person perA = new Person("张三",10) ;
		Person perB = new Person("李四",10) ;
        Person perC = new Person("王五",11) ;
	    System.out.println(perA.getInfo());
	    System.out.println(perB.getInfo());
	    System.out.println(perC.getInfo());
	}
}

```

​		为了更好的观察出程序的问题，下面对此操作做一个内存的分析。![image-20210401094945012](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210401094945012.png)

​		在正常开发过程之中每一个对象要保存有各自的属性，所以此时的程序没有任何问题，但是如果突然有一天，国家解放了变为了中华人民共和国。 并且你已经产生了5000W个对象，那么此时面对你的将是场噩梦。因为每一个对象都拥有各自的country属性，所以这个时候就会发现从整体的设计上就出现了问题（重复保存数据并且修改不方便）。

​		那么这个时候最好的解决方案就是将country修改为公共属性，而这种情况下就必须使用static进行标注。

**范例：**修改Person类定义，使用static定义公共属性。

```java
   static String country = "中华民国" ;    //  在上面的程序之中，在country属性之前加上static，表明它是公共属性。
```

​		此时会发现所有对象中的country属性的内容都发生了改变，所以这是一个公共属性，而此时的内存关系图如下。

![image-20210401100334821](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210401100334821.png)

​		但是对于static属性的访问需要注意一点：由于其本身是一个公共的属性，虽然可以通过对象进行访问，但是最好的做法应该是通过所有对象的最高代表（类）来进行访问，所以static属性可以由类名称直接调用。

```java
Person.country = "中华人民共和国";
```

​		static属性虽然定义在类之中，但是其并不受到类实例化对象的控制。static属性可以在没有实例化对象的时候使用。

**范例：**不产生实例化对象调用static属性

```java
public class JavaClassTest02 {
	public static void main(String[] args) {
	    System.out.println(Person1.country);
	    Person1.country = "中华人民共和国" ;
	    Person1 per = new Person1("张三",10) ;
	    System.out.println(per.getInfo());
	}
}
```

​		在以后进行类设计的时候首选的一定是非static属性（95%），而考虑到公共信息存储的时候才会使用到static（5%）。非static属性必须在实例化对象产生之后才可以使用，而static属性可以在没有实例化对象产生的情况下直接通过类名称进行调用。# static 定义方法

​		static关键字也可以进行方法的定义，static方法的主要特点在于，其可以直接由类名称在没有实例化对象的情况下进行调用。

```java
class Person1 {  //  创建所有同一个国家的类
    private String name ;
    private int age ;
    private static String country = "中华民国" ;    //  国家， 暂时不封装
    public Person1(String name,int age) {
        this.name = name;
        this.age = age;
    }
    public static void setCountry(String c) {
		country = c;
	}
    // setter、getter略
    public String getInfo() {
        return "姓名：" + this.name + "、年龄：" + this.age + "、国家: " + this.country;
    }
}
public class JavaClassTest02 {
	
	public static void main(String[] args) {
		Person1.setCountry("中国人民共和国");
	    Person1 per = new Person1("张三",10) ;
	    System.out.println(per.getInfo());
	}
}

```

​		这个时候对于程序而言方法就有了两种：static方法、非static方法，这两个方法之间在调用上就有了限制。

- static 方法只允许调用static属性或static方法；

- 非static方法允许调用static属性或static方法；



​		  所有的static定义的属性和方法都可以在没有实例化对象的前提下使用，而所有的非static定义的属性和方法必须要有实例化对象的情况下才可以使用。

​		如果说现在可以理解这个限制，那么对于之前的方法定义就可以得出新的结论：在最早讲解方法定义的时候强调过：“当前定义的方法都是在主类中定义的，并且由主方法调用的”

| public class StaticUse {<br/><br/>	public static void main(String[] args) {<br/>		printdy();<br/><br/>	}<br/>	public **static** void printdy() {<br/>		System.out.println("张祥牛逼！！！！");<br/><br/>	}<br/><br/>} | public class StaticUse {<br/><br/>	public static void main(String[] args) {<br/>		new StaticUse().printdy();<br/><br/>	}<br/>	public void printdy() {<br/>		System.out.println("张祥牛逼！！！！");<br/><br/>	}<br/><br/>} |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
|                                                              |                                                              |

​		static 定义的方法或者是属性都不是你代码编写之初所需要考虑的内容，只有在回避实例化对象调用并且描述公共属性的情况下才会考虑使用static定义的方法或者是属性。

# **Static 应用**

​		为了加强理解，下面做两个简单的程序来进行static应用的提示。

**范例：**编写一个程序类，这个类可以实现实例化对象个数的统计，每一次创建新的实例化对象都可以实现一个统计操作。

- 此时可以单独创建一个 static属性，因为所有对象都共享同一个static属性，那么在构造方法中可以实现数据的统计处理。

```java
class Book{
	private String title ;
	private static int count = 0 ;
	public Book(String title) {
		this.title = title;
		count++;
		System.out.println("第" + count + 
			"本新的图书被创建出来。");
	}
}

public class JavaDemo{
	public static void main(String[] args){
		new Book("JSP");
		new Book("Jav");
		new Book("Js");
		new Book("JP");
	}
}
```

**范例：**实现属性的自动命名处理

- ​		如果现在传递了title属性，就使用传递的属性内容，而如果没有传递title属性，则自动采用“NOTITLF-编号”的形式进行该属性内容的定义。

```java
class Book{
	private String title ;
	private static int count = 0 ;
	public Book() {
		this("NOTITLF-" + count++);
	}
	public Book(String title) {
		this.title = title;
		
	}
	public String getTitle() {
		return this.title;
	}
}
public class JavaDemo{
	public static void main(String[] args){
		System.out.println(new Book("JSP").getTitle());
		System.out.println(new Book("时间简史").getTitle());
		System.out.println(new Book("埋雷").getTitle());
		System.out.println(new Book().getTitle());
		System.out.println(new Book().getTitle());
	}
}

```

​		这样处理的好处是可以避免在没有设置title属性时内容为null的重复问题。.# 代码块

​		在程序之中使用 “{ }” 定义的结构就称为代码块，而后根据代码块出现的位置以及定义的关键字的不同，代码块可以分为：普通代码块、构造块、静态块、同步代码块，其中对于同步代码块是在多线程的时候才会进行讲解。

## 普通代码块

​		普通代码块的主要特点是定义在一个方法之中的代码块。

**范例：观察一个程序**

```java
public class JavaDemo{
    public static void main(String[] args){
        if(true){ // 条件一定满足
            int x = 10;  // 局部变量
            System.out.println("x = " + x);
        }
        int x = 100;  //  全局变量
        System.out.println("x = " + x);
    }
}
```

​		按照Java程序的开发标准规定相同名称的变量是不能够在同一个方法之中存在的，但是由于此时有不同的分界描述。但如果说要定义普通代码块，那么只需要将当前的if语句取消即可。

```java
public class JavaDemo{
    public static void main(String[] args){
        { // 普通代码块
            int x = 10;  // 局部变量
            System.out.println("x = " + x);
        }
        int x = 100;  //  全局变量
        System.out.println("x = " + x);
    }
}
```

 		可以在一个方法之中进行一些结构的拆分，以防止相同变量名称所带来的互相影响。

## 构造代码块

​		 构造块是定义在一个类之中的

**范例：**观察构造块

```java
class Person01{
	public Person01() {
		System.out.println("【构造方法】Person类构造方法执行");
	}
	{
		System.out.println("【构造块】Person构造块执行");
	}
}

public class JavaDemo01 {

	public static void main(String[] args){
        new Person01();
        new Person01();
        new Person01();
    }

}
```

## 静态代码块

​		静态代码块主要指的是使用static关键字定义的代码块，静态块的定义需要考虑到两种情况：主类中定义静态块、非主类中定义静态块。

**范例：**在非主类中进行静态块的定义

```java
class Person01{
	public Person01() {
		System.out.println("【构造方法】Person类构造方法执行");
	}
	static{
		System.out.println("【静态块】静态块执行。");
		
	}
	{
		System.out.println("【构造块】Person构造块执行");
	}
}

public class JavaDemo01 {

	public static void main(String[] args){
        new Person01();
    }
}
```

​		此时可以发现静态代码块会优先于构造块执行，并且不管有多少个实例化对象出现静态代码块只会执行一次，静态代码块的主要目的是为类中的静态属性初始化。

**范例：**观察静态属性初始化



```java
class Message {
    public static String getCountry(){
        //该消息的内容可能来自于网络或者其他服务器
        return "中华人民共和国" ;
    }
}
class Person {
    private static String country ;
    static {
        // 可能有很多语句要执行
        country = Message.getCountry();
        System.out.println(country) ; 
    }
}
public class JavaDemo {
    public static void main(String arg[]){
        new Person();   
    }
}
```

​		对于静态代码块还必须考虑另一种情况，在主类中定义的形式。

**范例：**在主类中进行静态代码块的定义

```java
public class JavaDemo {
    static {
        System.out.println("******* 程序初始化 ********") ;
    }
    public static void main(String arg[]){
        System.out.println("主方法输出");
    }
}
```

​		静态代码块优先于主方法先执行。











































```java
package org.jgs.pratice;

public class Address {
	private String country;
	private String province;
	private String city;
	private String street;
	private String postcode;
	public Address () {}  // 无参构造
	public Address (String country,String province,String city,String street,String postcode) {
		this.country = country;												// 有参构造
		this.province = province;
		this.city = city;
		this.street = street;
		this.postcode = postcode;
	}
	public void setCountry(String country) {
		this.country = country;
	}
	public void setProvince(String province) {
		this.province = province;
	}
	public void setCity(String city) {
		this.city = city;
	}
	public void setStreet(String street) {
		this.street = street;
	}
	public void setPostcode(String postcode) {
		this.postcode = postcode;
	}
	public String getCountry() {
		return country;
	}
	public String getProvince() {
		return province;
	}
	public String getCity() {
		return city;
	}
	public String getStreet() {
		return street;
	}
	public String getPostcode() {
		return postcode;
	}
	public String getInfo() {
		
		return this.country + "" + this.province + "省" + this.city + "市" + this.street +
				"(街/道)" + this.postcode;

	}
	
}

```

#  案例分析二

​		定义并测试一个代表员工的Employee类。员工属性包括“编号”、“姓名”、“基本薪水”、“薪水增长率”，还包括计算薪水增长额及计算增长后的工资总额的操作方法。

​		这个程序的功能已经超过了简单Java类的定义范畴，因为简单Java类里面不需要涉及到复杂的计算逻辑，但是设计的思考是应该从简单java类开始。

```java

/**
 * @Description
 *  案例分析二
 * 		定义并测试一个代表员工的Employee类。员工
 * 属性包括“编号”、“姓名”、“基本薪水”、“薪水增长
 * 率”，还包括计算薪水增长额及计算增长后的工资总额
 * 的操作方法。
 * @author AlexYU Email:alex2354629991@gmail.com
 * @version
 * @date 2021年4月6日下午5:02:04
 */
public class Employee {
	private long code;
	private String name;	
	private double salary;
	private double rate;
	public Employee () {}
	public Employee (long code,String name,double salary,double rate) {
		this.code = code;
		this.name = name;
		this.salary = salary;
		this.rate = rate;
	}
	// 得到薪水增长额度
	public double salaryIncValue() {
		return this.salary * this.rate ;
	}
	// 计算薪水增长总额
	public double salaryIncResult() {
		
		this.salary = this.salary + this.salaryIncValue();
		
		return this.salary ;
	}
	public String getInfo() {
		return "编号:" + this.code + "、姓名:" + name + "、基本薪水:" + salary + "、薪水增长率:" + rate;
	// setter、getter略
	}
}

```

# 案例分析三

设计一个Dog类，有名字、颜色、年龄等属性，定义构造方法来初始化类的这些属性，定义构造方法来初始化类的这些属性，定义方法输出Dog信息，编写应用程序使用Dog类。

```java
/**
 * @Description
 * 		设计一个Dog类，有名字、颜色、年龄等属
 * 性，定义构造方法来初始化类的这些属性，定义构造方法
 * 来初始化类的这些属性，定义方法输出Dog信息，编写应用
 * 程序使用Dog类。
 * @author AlexYU Email:alex2354629991@gmail.com
 * @version
 * @date 2021年4月6日下午6:40:17
 */
public class Dog {
	private String name;
	private String color;
	private int age;
	public Dog() {}
	public Dog(String name,String color,int age) {
		this.age = age;
		this.name = name;
		this.color = color;
	}
	// setter、getter略
	public String getInfo() {
		return "名字是："+name+"\n毛色："+color+"\n年龄："+age;
	}
}

```

# 案例分析四

​		构造一个银行账户类，类的构成包括如下内容：

（1）、数据成员用户的账户名称、用户的账户余额（private数据类型）。
（2）、方法包括开户（设置账户名称及余额），利用构造方法完成。
（3）、查询余额。

```java
public class Account {
	private String name;
	private double balence;
	public Account() {}
	public Account(String name) {
		this(name,0.0);  // 调用双参构造
	}
	public Account(String name,double balence) {
		this.name = name;
		this.balence = balence;
	}
	public double getBalence() {
		return balence;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public void setBalence(double balence) {
		this.balence = balence;
	}
	public String getInfo() {
		return "账户名称：" + this.name + "\n账户余额：" + this.balence;

	}
}

```

# 案例分析五

​		设计一个表示用户的User类，类中的变量有用户名、口令和记录用户个数的变量，定义类的3个构造方法（无参、为用户名赋值、为用户名和口令赋值）、获取和设置口令的方法和返回类信息的方法。

```java
class User {
    private String uid;
    private String password;
    private static int count = 0;
    public User(){
        this("NOID","bdqn");
    }
    public User(String uid){
        this(uid,"jgs2111");
    }
    public User(Strong uid,String password){
        this.uid = uid;
        this.password = password;
        count ++ ; // 个数追加
    }
    // setter、getter略
    public static int getCount(){ //  获得用户个数
        return count;
        
    }
    public String getInfo() {
        return "用户名："+uid+"\n密码："+password;
    }
}
```

# 案例分析六

​		声明了个图书类，其数据成员为书名、编号（利用静态变量实现自动编号）、书价，并拥有静态数据成员册数、记录图书册数，在构造方法中利用此静态变量为对象的编号赋值，在主方法中定义多个对象，并求出总册数。

```java

/**
 * @Description 案例分析六
 * 声明了个图书类，其数据成员为书名、编号（利用静态变量实现自动编号）、
 * 书价，并拥有静态数据成员册数、记录图书册数，在构造方法中利
 * 用此静态变量为对象的编号赋值，在主方法中定义多个对象，并求出总册数。
 * @author AlexYU Email:alex2354629991@gmail.com
 * @version
 * @date 2021年4月6日下午7:40:25
 */
public class Book{
    private int bid;  // 编号
    private String title;  // 书名
    private static int count = 0;
    private double price;  // 价格
    public Book(String title,double price){
        this.bid = ++ count ;  // 先赋值再自增
        this.title = title;
        this.price = price;
    }
    // setter、getter略
    public String getInfo(){
        return "编号："+this.bid+"\t书名："+title+"\t价格："+price;
    }
    public static int getCount() {
    	return count;
    }
}
public class JavaDemo {
    
    public static void main(String arg[]){
    	Book b1 = new Book("javascript", 10.90);
    	Book b2 = new Book("java", 156.2220);
    	Book b3 = new Book("typescript", 18.90);
    	System.out.println(b1.getInfo());
    	System.out.println(b2.getInfo());
    	System.out.println(b3.getInfo());
    	System.out.println(Book.getCount());
    }
}
```

​		在面向对象最基础的开发里面，简单Java类是解决先期设计最好的方案。# 成员属性封装

​		在类之中的组成就是属性与方法，一般而言方法都是对外提供服务的，所以是不会进行封装处理的，而对于属性来说，由于其需要较高的安全性，所以往往需要对其进行保护，这个时候就需要采用封装性对其保护。

​		在默认的情况下，对于类中的属性是可以通过其他类利用对象进行调用的。

**范例：**属性不封装情况下的问题

```java
public class ClassTest {   // 主类
	
	public static void main (String[] args) {
		Person per = new Person();//声明并实例化对象
		per.name = "张三";  // 在类外部修改属性
		per.age  = 23;  // 在类外部修改属性
		per.tell();//进行方法的调用
	}
}
```

​		此时在Person类中提供的name与age两个属性并没有进行封装处理，这样外部就可以直接进行调用了，但是有可能所设置的数据是错误的数据。如果要想解决这样的问题就可以利用Private关键字对属性进行封装处理。

**范例**:对属性进行封装

```java
public class Person {
	private String name;
	private int age;
	public String tell() {
		System.out.println("姓名:"+ name + "\n年龄：" + age);
		return "姓名:"+ name + "\n年龄：" + age;
	}

```

​		而属性一旦封装完成，将对外部不可见；即：外部不能直接访问，但是对类内部是可见，那么如果要想让外部的程序想要访问封装属性，则在Java开发标准中提供有如下要求：

- ​		【setter、getter】设置或取得属性可以使用setXxx()、getXxx()方法，以：private String name;为例
  			- 设置属性方法：public void setName(String n);
  			- 获取属性方法：public String getName();

**范例**：实现封装

```java
public class Person {
	private String name;
	private int age;
	public String tell() {
		System.out.println("姓名:"+ name + "\n年龄：" + age);
		return "姓名:"+ name + "\n年龄：" + age;
	}
	public void setName(String n) {
		name = n;
	}
	public void setAge(int a) {
		if (a > 0) {
			age = a;
		}
	}
	public String getName() {
		return name;
	}
	public int getAge() {
		return age;
	}
public static void main (String[] args) {
		Person per = new Person();//声明并实例化对象
		per.setName("张三");  // 在类外部修改属性
		per.setAge(-18);  // 在类外部修改属性
		per.tell();//进行方法的调用
	}
```

​		在以后进行任何类定义的时候一定要记住，类中所有属性都必须使用private封装（98%），并且

属性如果要进行访问必须提供setter与getter方法。# 对象实例化操作初步分析

​		JAVA之中类属于引用数据类型，引用数据类型最大的困难之有处在于要进行内存的管理，同时在进行操作的时候也会发生有内存关系的变化，所以本次针对于之前的程序内存关系进行一些简单的分析。

**范例**：以下面的程序为主进行分析

```java
package com.kgc.classd;

public class ClassTest {
	
	public static void main (String[] args) {
		Person zsPerson = new Person();//声明并实例化对象
		zsPerson.name = "张三";
		zsPerson.age  = 23;
		zsPerson.tell();//进行方法的调用
	}
}

```

​		如果要进行内存分析，那么首先给出两块最为常用的内存空间：

- ​		堆内存：保存的是对象的具体信息，在程序之中堆内存空间的开辟是通过new关键字完成的。
- ​		栈内存：保存的是一块堆内存的地址，即：通过地址找到堆内存，而后找到对象内容，但是为了分析简单起见，可以简单地理解为：对象名称保存在了栈内存之中

### 堆栈模型

![image-20210329090444032](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329090444032.png)

### 内存分析

![image-20210329091339610](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329091339610.png)

对象的实例化有两种语法，一种是使用之前的声明并实例化对象，另一种就是分步完成，所以下面针对于分布的内存操作进行分析。

**范例：定义程序代码**

```java
public class ClassTest {
	public static void main (String[] args) {
		Person per = null;  // 声明对象
		per = new Person(); // 实例化对象
		per.name = "张三";
		per.age  = 23;
		per.tell();//进行方法的调用
	}
}

```

​		下面通过内存分析来进行解释。。

![image-20210329093417424](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329093417424.png)

​		需要特别引起注意的是，所有的对象在调用类中的属性或方法的时候必须要实例化完成。

**范例**：错误的代码

```java
public class ClassTest {
	public static void main (String[] args) {
		Person per = null;  // 声明对象
        //未实例化对象
		per.name = "张三";
		per.age  = 23;
		per.tell();//进行方法的调用
	}
}

```

# 代码块

​		在程序之中使用 “{ }” 定义的结构就称为代码块，而后根据代码块出现的位置以及定义的关键字的不同，代码块可以分为：普通代码块、构造块、静态块、同步代码块，其中对于同步代码块是在多线程的时候才会进行讲解。

## 普通代码块

​		普通代码块的主要特点是定义在一个方法之中的代码块。

**范例：观察一个程序**

```java
public class JavaDemo{
    public static void main(String[] args){
        if(true){ // 条件一定满足
            int x = 10;  // 局部变量
            System.out.println("x = " + x);
        }
        int x = 100;  //  全局变量
        System.out.println("x = " + x);
    }
}
```

​		按照Java程序的开发标准规定相同名称的变量是不能够在同一个方法之中存在的，但是由于此时有不同的分界描述。但如果说要定义普通代码块，那么只需要将当前的if语句取消即可。

```java
public class JavaDemo{
    public static void main(String[] args){
        { // 普通代码块
            int x = 10;  // 局部变量
            System.out.println("x = " + x);
        }
        int x = 100;  //  全局变量
        System.out.println("x = " + x);
    }
}
```

 		可以在一个方法之中进行一些结构的拆分，以防止相同变量名称所带来的互相影响。

## 构造代码块

​		 构造块是定义在一个类之中的

**范例：**观察构造块

```java
class Person01{
	public Person01() {
		System.out.println("【构造方法】Person类构造方法执行");
	}
	{
		System.out.println("【构造块】Person构造块执行");
	}
}

public class JavaDemo01 {

	public static void main(String[] args){
        new Person01();
        new Person01();
        new Person01();
    }

}
```

## 静态代码块

​		静态代码块主要指的是使用static关键字定义的代码块，静态块的定义需要考虑到两种情况：主类中定义静态块、非主类中定义静态块。

**范例：**在非主类中进行静态块的定义

```java
class Person01{
	public Person01() {
		System.out.println("【构造方法】Person类构造方法执行");
	}
	static{
		System.out.println("【静态块】静态块执行。");
		
	}
	{
		System.out.println("【构造块】Person构造块执行");
	}
}

public class JavaDemo01 {

	public static void main(String[] args){
        new Person01();
    }
}
```

​		此时可以发现静态代码块会优先于构造块执行，并且不管有多少个实例化对象出现静态代码块只会执行一次，静态代码块的主要目的是为类中的静态属性初始化。

**范例：**观察静态属性初始化



```java
class Message {
    public static String getCountry(){
        //该消息的内容可能来自于网络或者其他服务器
        return "中华人民共和国" ;
    }
}
class Person {
    private static String country ;
    static {
        // 可能有很多语句要执行
        country = Message.getCountry();
        System.out.println(country) ; 
    }
}
public class JavaDemo {
    public static void main(String arg[]){
        new Person();   
    }
}
```

​		对于静态代码块还必须考虑另一种情况，在主类中定义的形式。

**范例：**在主类中进行静态代码块的定义

```java
public class JavaDemo {
    static {
        System.out.println("******* 程序初始化 ********") ;
    }
    public static void main(String arg[]){
        System.out.println("主方法输出");
    }
}
```

​		静态代码块优先于主方法先执行。

```java
package org.jgs.pratice;

public class Address {
	private String country;
	private String province;
	private String city;
	private String street;
	private String postcode;
	public Address () {}  // 无参构造
	public Address (String country,String province,String city,String street,String postcode) {
		this.country = country;												// 有参构造
		this.province = province;
		this.city = city;
		this.street = street;
		this.postcode = postcode;
	}
	public void setCountry(String country) {
		this.country = country;
	}
	public void setProvince(String province) {
		this.province = province;
	}
	public void setCity(String city) {
		this.city = city;
	}
	public void setStreet(String street) {
		this.street = street;
	}
	public void setPostcode(String postcode) {
		this.postcode = postcode;
	}
	public String getCountry() {
		return country;
	}
	public String getProvince() {
		return province;
	}
	public String getCity() {
		return city;
	}
	public String getStreet() {
		return street;
	}
	public String getPostcode() {
		return postcode;
	}
	public String getInfo() {
		
		return this.country + "" + this.province + "省" + this.city + "市" + this.street +
				"(街/道)" + this.postcode;

	}
	
}

```

#  案例分析二

​		定义并测试一个代表员工的Employee类。员工属性包括“编号”、“姓名”、“基本薪水”、“薪水增长率”，还包括计算薪水增长额及计算增长后的工资总额的操作方法。

​		这个程序的功能已经超过了简单Java类的定义范畴，因为简单Java类里面不需要涉及到复杂的计算逻辑，但是设计的思考是应该从简单java类开始。

```java

/**
 * @Description
 *  案例分析二
 * 		定义并测试一个代表员工的Employee类。员工
 * 属性包括“编号”、“姓名”、“基本薪水”、“薪水增长
 * 率”，还包括计算薪水增长额及计算增长后的工资总额
 * 的操作方法。
 * @author AlexYU Email:alex2354629991@gmail.com
 * @version
 * @date 2021年4月6日下午5:02:04
 */
public class Employee {
	private long code;
	private String name;	
	private double salary;
	private double rate;
	public Employee () {}
	public Employee (long code,String name,double salary,double rate) {
		this.code = code;
		this.name = name;
		this.salary = salary;
		this.rate = rate;
	}
	// 得到薪水增长额度
	public double salaryIncValue() {
		return this.salary * this.rate ;
	}
	// 计算薪水增长总额
	public double salaryIncResult() {
		
		this.salary = this.salary + this.salaryIncValue();
		
		return this.salary ;
	}
	public String getInfo() {
		return "编号:" + this.code + "、姓名:" + name + "、基本薪水:" + salary + "、薪水增长率:" + rate;
	// setter、getter略
	}
}

```

# 案例分析三

设计一个Dog类，有名字、颜色、年龄等属性，定义构造方法来初始化类的这些属性，定义构造方法来初始化类的这些属性，定义方法输出Dog信息，编写应用程序使用Dog类。

```java
/**
 * @Description
 * 		设计一个Dog类，有名字、颜色、年龄等属
 * 性，定义构造方法来初始化类的这些属性，定义构造方法
 * 来初始化类的这些属性，定义方法输出Dog信息，编写应用
 * 程序使用Dog类。
 * @author AlexYU Email:alex2354629991@gmail.com
 * @version
 * @date 2021年4月6日下午6:40:17
 */
public class Dog {
	private String name;
	private String color;
	private int age;
	public Dog() {}
	public Dog(String name,String color,int age) {
		this.age = age;
		this.name = name;
		this.color = color;
	}
	// setter、getter略
	public String getInfo() {
		return "名字是："+name+"\n毛色："+color+"\n年龄："+age;
	}
}

```

# 案例分析四

​		构造一个银行账户类，类的构成包括如下内容：

（1）、数据成员用户的账户名称、用户的账户余额（private数据类型）。
（2）、方法包括开户（设置账户名称及余额），利用构造方法完成。
（3）、查询余额。

```java
public class Account {
	private String name;
	private double balence;
	public Account() {}
	public Account(String name) {
		this(name,0.0);  // 调用双参构造
	}
	public Account(String name,double balence) {
		this.name = name;
		this.balence = balence;
	}
	public double getBalence() {
		return balence;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public void setBalence(double balence) {
		this.balence = balence;
	}
	public String getInfo() {
		return "账户名称：" + this.name + "\n账户余额：" + this.balence;

	}
}

```

# 案例分析五

​		设计一个表示用户的User类，类中的变量有用户名、口令和记录用户个数的变量，定义类的3个构造方法（无参、为用户名赋值、为用户名和口令赋值）、获取和设置口令的方法和返回类信息的方法。

```java
class User {
    private String uid;
    private String password;
    private static int count = 0;
    public User(){
        this("NOID","bdqn");
    }
    public User(String uid){
        this(uid,"jgs2111");
    }
    public User(Strong uid,String password){
        this.uid = uid;
        this.password = password;
        count ++ ; // 个数追加
    }
    // setter、getter略
    public static int getCount(){ //  获得用户个数
        return count;
        
    }
    public String getInfo() {
        return "用户名："+uid+"\n密码："+password;
    }
}
```

# 案例分析六

​		声明了个图书类，其数据成员为书名、编号（利用静态变量实现自动编号）、书价，并拥有静态数据成员册数、记录图书册数，在构造方法中利用此静态变量为对象的编号赋值，在主方法中定义多个对象，并求出总册数。

```java

/**
 * @Description 案例分析六
 * 声明了个图书类，其数据成员为书名、编号（利用静态变量实现自动编号）、
 * 书价，并拥有静态数据成员册数、记录图书册数，在构造方法中利
 * 用此静态变量为对象的编号赋值，在主方法中定义多个对象，并求出总册数。
 * @author AlexYU Email:alex2354629991@gmail.com
 * @version
 * @date 2021年4月6日下午7:40:25
 */
public class Book{
    private int bid;  // 编号
    private String title;  // 书名
    private static int count = 0;
    private double price;  // 价格
    public Book(String title,double price){
        this.bid = ++ count ;  // 先赋值再自增
        this.title = title;
        this.price = price;
    }
    // setter、getter略
    public String getInfo(){
        return "编号："+this.bid+"\t书名："+title+"\t价格："+price;
    }
    public static int getCount() {
    	return count;
    }
}
public class JavaDemo {
    
    public static void main(String arg[]){
    	Book b1 = new Book("javascript", 10.90);
    	Book b2 = new Book("java", 156.2220);
    	Book b3 = new Book("typescript", 18.90);
    	System.out.println(b1.getInfo());
    	System.out.println(b2.getInfo());
    	System.out.println(b3.getInfo());
    	System.out.println(Book.getCount());
    }
}
```

​		在面向对象最基础的开发里面，简单Java类是解决先期设计最好的方案。
# 引用传递分析

​		

类本身属于引用数据类型，既然是引用数据类型，那么就牵扯到内存的引用传递，所谓的内存的引用传递就是同一块堆内存的空间可以被不同的栈内存所指向，也可以更换指向。。

**范例**：定义一个引用传递的分析程序。

```java
public class ClassTest {
	
	public static void main (String[] args) {
		Person per1 = new Person();//声明并实例化对象
		per1.name = "张三";
		per1.age  = 23;
		Person per2 = per1;  // 引用传递
		per2.age = 80;
		per1.tell();//进行方法的调用
	}
}
```

![image-20210329100756247](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329100756247.png)

​		这个时候的引用传递是直接在主方法之中定义的，也可以通过方法实现引用传递处理。

**范例**：利用方法实现引用传递

```java
public class ClassTest {
	
	public static void main (String[] args) {
		Person per = new Person();//声明并实例化对象
		per.name = "张三";
		per.age  = 23;
		change(per);// 等价于：Person temp = per ;
		per.tell();//进行方法的调用
	}
	
	public static void change(Person temp) {
		temp.age = 70;
	}
	
}
运行结果：
姓名:张三
年龄：70
```

与之前最大的区别就是，此时的程序是将Person类的实例化对象（内存地址、数值）传递到了change（）方法之中，由于传递的是一个Person类型，那么change（）方法接收的也是Person类型。

#### 内存分析

##### ![image-20210329103520841](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329103520841.png)

​		引用传递可以发生在方法上，这个时候一定要观察方法的参数类型，同时也要观察方法的执行过程。

# 引用传递与垃圾产生分析

​		经过了一系列的分析之后已经确认，所有的引用传递的本质就是一场堆内存的调戏游戏。

但是对于引用传递如果处理不当那么也会造成垃圾的产生，那么本次将针对于垃圾产生原因

进行简单分析。

范例：定义一个要分析的程序

```java
public static void main (String[] args) {
		Person per1 = new Person();//声明并实例化对象
		Person per2 = new Person();//声明并实例化对象
		per1.name = "张三";
		per1.age  = 23;
		per2.name = "李四";
		per2.age  = 26;
		
		per2 = per1;  // 引用传递
		per2.age = 80;
		per1.tell();//进行方法的调用
	}
```

此时明确的发生了引用传递，并且也成功的完成了引用传递的处理操作，但是下面来观察一下其

内存的分配与处理流程。

*一个栈内存只能够保存有一个堆内存的地址数据，如果发生更改，则之前的地址数据将从此栈内存中彻底消失。*

![image-20210329105503299](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329105503299.png)

​		所谓的垃圾空间指的就是没有任何栈内存所指向的堆内存空间，所有的垃圾将被GC（GarbageCollector、垃圾收集器）不定期进行回收并且释放无用内存空间，但是如果垃圾过多，一定将影响到GC的处理性能，从而降低整体的程序性能，那么在实际开发中，对于垃圾的产生越少越好。# 构造方法与匿名对象

​		现在的程序在使用类的时候一般都按照如下的步骤进行：

- ​	声明并实例化对象，这个时候实例化对象中的属性并没有任何的数据存在，都是其对应数据类型的默认值；
-    ​    需要通过一系列的setter方法为类中的属性设置内容。

  等于现在要想真正获得一个可以正常使用的实例化对象，必须经过两个步骤才可以完成。

#### **范例：传统调用**

```java
public class Person {
	private String name;
	private int age;
	public String tell() {
		System.out.println("姓名:"+ name + "\n年龄：" + age);
		return "姓名:"+ name + "\n年龄：" + age;
	}
	public void setName(String n) {
		name = n;
	}
	public void setAge(int a) {
		
		age = a;
	
	}
	public String getName() {
		return name;
	}
	public int getAge() {
		return age;
	}
}
public class ClassTest {   // 主类
	
	public static void main (String[] args) {
		//1、对象初始化准备
		Person per = new Person();//声明并实例化对象
		per.setName("张三");  // 在类外部修改属性
		per.setAge(-18);  // 在类外部修改属性
		//2、对象的使用
		per.tell();//进行方法的调用
	}
}
```

	new Student()  类名()  Student() 构造方法  特殊方法 用于创建对象
1.如果类中没有显示定义构造方法 虚拟机会帮我们自动提供一个无参的构造方法

2.如果类中有定义构造方法 虚拟机不在提供一个无参的构造方法

普通方法：

权限修饰符 返回值 方法名(参数列表){}



构造方法：

权限修饰符(public) 方法名(参数列表){方法体}

1.没有返回值  不要写void

2.构造方法名必须和类名保持一致

3.构造方法用于创建对象   使用关键字new 来调用

4.构造方法也是可以重载的

5.构造方法之间可以互相调用 使用this() 但是要保证this() 要在第一行

6.构造方法可以调用普通的方法 反之不行

但是如果按照这样的方式来进行思考就会发现一个问题：假设说现在类中的属性很多个（8个），按照以前的做法，此时就需要调用8次setter方法进行内容设置。这样的调用实在是太啰嗦了，所以在Java里面为了考虑到对象初始化的问题，专门提供有构造方法，即：**可以通过构造方法实现实例化对象中属性初始化处理**。只有在关键字new的时候使用构造方法，在Java程序里面构造方法的定义要求如下：

- ​	构造方法名称必须与类名保持一致；
- ​    构造方法不允许设置任何的返回值类型，即：没有返回值定义；
- ​    构造方法是在使用关键子new实例化对象的时候自动调用的。

#### **范例：定义构造方法**

```java
public class Person {
	private String name;
	private int age;
	// 方法名称与类名相同，并且无返回值定义
	public Person(String n,int a) { // 定义有参构造
		name = n; // 为类中的属性赋值（初始化）
		age = a;  // 为类中的属性赋值（初始化）
	}
	public String tell() {
		System.out.println("姓名:"+ name + "\n年龄：" + age);
		return "姓名:"+ name + "\n年龄：" + age;
	}
}
public class ClassTest {   // 主类
	
	public static void main (String[] args) {
		//1、对象初始化准备
		Person per = new Person("张三",16);//声明并实例化对象
		//2、对象的使用
		per.tell();//进行方法的调用
	}
}
```

下面针对于当前与之前的实例化格式做一个比较：

- 之前的实例化格式：

  ```
  ①Person ②per = ③new ④Person();//声明并实例化对象
  ```

- 当前的实例化格式：

  ```
  ①Person ②per = ③new ④Person("张三",16);//声明并实例化对象
  ```

  “①Person”：主要是定义对象的所属类型，类型决定了可以调用的方法

  “②per”      ：实例化对象的名称，所有的操作通过对象来进行访问；

  “③new”    ：开辟一块新的堆内存空间；

  “④Person("张三",16)”：调用有参构造、“④Person()”调用无参构造；

  ​		在Java程序里面考虑到程序结构的完整性，所以所有的类都会提供有构造方法，也就是说如果现在你的类中没有定义任何的构造方法，那么一定会默认提供一个无参的，什么都不做的构造方法，这个构造方法是在程序编译的时候自动创建的。如果你现在已经在类中明确的定义有一个构造方法的时候，那么这个默认的构造方法将不会被自动创建。

  ​		**结论：一个类至少存在有一个构造方法，永恒存在。**

**疑问：为什么构造方法上不允许设置返回类型？**

​		*既然构造方法是一个方法，那么为什么不让它定义返回值类型呢？*

​		*既然构造方法不会返回数据，为什么不使用void定义呢？*

分析：程序编译器是根据代码结构来进行编译处理的，执行的时候也是根据代码结构来处理的。*如果在构造方法上使用了void，那么此结构就与普通方法结构完全相同了，这样编译器会认为此方法是一个普通方法，普通方法与构造方法最大的区别：构造方法是在类对象实例化的时候调用的，而普通方法是在类对象实例化产生之后调用的。*

既然构造方法本身是一个方法，那么方法就具有重载的特点，而构造方法重载的时候只需要考虑参数的类型及个数即可。

#### **范例：**构造方法重载

```java
public class Person {
	private String name;
	private int age;
	public Person() {
		name = "无名氏";
		age = -1;
	};
	public Person(String n) {
		name = n;
	};
	// 方法名称与类名相同，并且无返回值定义
	public Person(String n,int a) { // 定义有参构造
		name = n; // 为类中的属性赋值（初始化）
		age = a;  // 为类中的属性赋值（初始化）
	}
	public String tell() {
		System.out.println("姓名:"+ name + "\n年龄：" + age);
		return "姓名:"+ name + "\n年龄：" + age;
	}
}
public class ClassTest {   // 主类	
	public static void main (String[] args) {
		//1、对象初始化准备
		Person per = new Person();//声明并实例化对象
		//2、对象的使用
		per.tell();//进行方法的调用
	}
}
```

​		在进行多个构造方法定义的时候强烈建议大家一些定义的顺序,例如: 可以按照**参数的个数降序或升序排列**。经过分析可以发现,构造方法的确是可以行数据的设置,而对于setter也可以进行数据的设置，这个时候一定要清楚，构造方法是在对象实例化的时候为属性设置初始化内容,而 setter除了拥有设置数据的功能之外,还具有修改数据的功能。

#### 范例:使用 setter修改数据

```java
public class Person {
	private String name;
	private int age;

	public Person() {
		name = "无名氏";
		age = -1;
	};

	public Person(String n) {
		name = n;
	};

	// 方法名称与类名相同，并且无返回值定义
	public Person(String n, int a) { // 定义有参构造
		name = n; // 为类中的属性赋值（初始化）
		age = a; // 为类中的属性赋值（初始化）
	}
	public String tell() {
		System.out.println("姓名:" + name + "\n年龄：" + age);
		return "姓名:" + name + "\n年龄：" + age;
	}
	public void setName(String n) {
		name = n;
	}
	public void setAge(int a) {
		age = a;
	}
	public String getName() {
		return name;
	}
	public int getAge() {
		return age;
	}
}
public class ClassTest {   // 主类
	
	public static void main (String[] args) {
		//1、对象初始化准备
		Person per = new Person("张三",98);//声明并实例化对象
		//2、对象的使用
		per.setAge(18);
		per.tell();//进行方法的调用
	}
}

```

​		经过了分析之后可以发现,利用构造方法可以传递属性数据,于是现在进一步分析对象的产生格式：

- 定义对象的名称:  类名称对象名称=nul 
- 实例化对象:        对象名称new类名称()

如果这个时候只是通过实例化对象来进行类的作也是可以的,而这种形式的对象由于没有名字就称为匿名对象.

#### 范例:  观察匿名对象

```java
public class ClassTest {   // 主类
	public static void main (String[] args) {
		new Person("张三",98).tell();//进行方法的调用
	}
}
```

​		此时依然通过了对象进行了类中tel方法的调用,但是由于此对象没有任何的引用名称,所以该对象使用一次之后就将成为垃圾,而所有的垃圾将被GC进行回收与释放。

​		现在发现此时的程序里面已经存在有构造方法了,那么下面通过一个程序来利用构造方法进行一次内存分析.

#### 范例:  编写一个分析程序

```java
package com.kgc.classd;

class Message{
	private String title;
	public Message(String t){
		title = t;
	}
	public String getTitle(){
		return title;
	}
	public void setTitle(String t){ // 具有修改功能
		title = t;
	}
}
class Person {
	private String name;
	private int age;
	// 方法名称与类名相同，并且无返回值定义
	public Person(Message msg, int a) { // 定义有参构造
		name = msg.getTitle(); // 为类中的属性赋值（初始化）
		age = a; // 为类中的属性赋值（初始化）
	}
	public Message getInfo() {
		return new Message(name + ":" + age);
	}
	public String tell() {
		System.out.println("姓名:" + name + "\n年龄：" + age);
		return "姓名:" + name + "\n年龄:" + age;
	}
}
public class JavaClassTest {   // 主类
	
	public static void main (String[] args) {
		Message msg = new Message("mlkj");
		Person Person = new Person(msg,20);
		msg = Person.getInfo();
		System.out.println(msg.getTitle());
	}
}
```

下面通过此程序进行一个简短的内存分析。.

![image-20210330095522637](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210330095522637.png)

​		只要是方法都可以传递任意的数据类型（基本数据类型、引用数据类型）。
# this关键字

this可以算是Java里面比较复杂的关键字，因为this的使用形式上决定了它的灵活性。在程序里面，使用this可以实现三类结构的描述：.

- ```
  当前类中的属性：this.属性；
  ```

- ```
  当前类中的方法（普通方法、构造方法）：this（）、this.方法名称（）；
  ```

- ```
  描述当前对象；
  ```

## 使用this 调用当前类中属性。

 		通过现在的分析可以发现，利用构造方法或者是setter方法都可以进行类中的属性的赋值，但是在进行赋值的时候，之前采用的是如下定义形式：

```java
class Person {
	private String name;
	private int age;
	// 方法名称与类名相同，并且无返回值定义
	public Person(String n,int a) {
		name = n;
		age = a;
	}
	public void tell() {
		System.out.println("姓名："+ name + "\n年龄：" + age);
	}
	// setter、getter略 
}
public class JavaClassTest {   // 主类
	
	public static void main (String[] args) {
		Person person = new Person("王五", 38);
		person.tell();
	}
}
```

​		但是这个时候在构造方法定义的过程之中会发现有一点点的问题：

```java
public Person(String n,int a) {
		name = n;
		age = a;
	}
```

​		这个问题出现在参数名称上，可以发现，此时构造方法中两个参数的目的是为了类中的name或age属性初始化，但是现在却发现此时的代码n和a参数名称不好。

​		如果说现在将构造方法中的参数名称修改为name、age，则发现无法进行属性的正确设置：

​		

```java
public Person(String n,int a) {
		name = name;
		age = age;
	}
```

在Java程序之中“{}”是作为一个结构体的边界符，那么在程序里面当进行变量（参数、属性都称为变量）使用的时候都会以“{}”作为一个查找边界，所以按照就近取用的原则，此时的构造方法并没有能够访问类中的属性，所以此时为了明确的标记出类中的属性与参数的区别，往往会在属性前追加一个“this”，表示本类属性。

```java
class Person {
	private String name;
	private int age;
	// 方法名称与类名相同，并且无返回值定义
	public Person(String name,int age) {
		this.name = name;
		this.age = age;
	}
	public void tell() {
		System.out.println("姓名："+ this.name + "\n年龄：" + this.age);
	}
	// setter、getter略 
}
```

​		在你以后所编写的程序代码之中，只要是访问本类中属性的时候，请一定要加上“this”# 使用this调用方法

​		除了调用属性之外，this也可以实现方法的调用，但是对于方法的调用就必须考虑构造与普通方法：

- 构造方法调用（this（））：使用关键字new实例化对象的时候才会调用构造方法；

- 普通方法调用（this.方法名称（））：实例化对象产生之后就可以调用普通方法。

## 范例：调用类中的普通方法

```java
class Person {
	private String name;
	private int age;
	// 方法名称与类名相同，并且无返回值定义
	public Person(String name,int age) {
		this.setName(name);
		setAge(age);// 加与不加都表示本类 
	}
	public void tell() {
		System.out.println("姓名："+ this.name + "\n年龄：" + this.age);
	}
	public void setName(String name) {
		this.name = name;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public String getName() {
		return this.name;
	}
	public int getAge() {
		return this.age;
	}
}
public class JavaClassTest {   // 主类
	
	public static void main (String[] args) {
		Person person = new Person("王五", 38);
		person.tell();
	}
}
```

​		除了普通的方法调用之外，还需要进行构造方法的调用，对于构造方法的调用，肯定是要放在构造方法中执行。现在假设说类中一共定义有三个构造方法，但是要求不管调用那个构造方法，都执行一行输出语句“一个新的Person类对象实例化”。

> | 传统方法                                                     | 利用this（）构造调用优化：                                   |
> | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | class Person {<br/>	private String name;<br/>	private int age;<br/>	// 方法名称与类名相同，并且无返回值定义<br/>	public Person() {<br/>		System.out.println("***一个新的Person类对象实例化。");<br/>	}<br/>	public Person(String name) {<br/>		this.name = name;<br/>		System.out.println("***一个新的Person类对象实例化。");<br/>	}<br/>	public Person(String name,int age) {<br/>		this.name = name;<br/>		this.age = age;<br/>		System.out.println("***一个新的Person类对象实例化。");<br/>	}<br/>	public void tell() {<br/>		System.out.println("姓名："+ this.name + "\n年龄：" + this.age);<br/>	}<br/>	// setter、getter略<br/>}<br/>public class JavaClassTest {   // 主类<br/>	<br/>	public static void main (String[] args) {<br/>		Person person = new Person();<br/>		person.tell();<br/>	}<br/>} | class Person {<br/>	private String name;<br/>	private int age;<br/>	// 方法名称与类名相同，并且无返回值定义<br/>	public Person() {<br/>		System.out.println("***一个新的Person类对象实例化。");<br/>	}<br/>	public Person(String name) {<br/>		**this();**    //  调用本类无参构造<br/>		this.name = name;<br/>	}<br/>	public Person(String name,int age) {<br/>		this(name);    //  调用本类单参构造<br/>		this.age = age;<br/>	}<br/>	public void tell() {<br/>		System.out.println("姓名："+ this.name + "\n年龄：" + this.age);<br/>	}<br/>	// setter、getter略<br/>}<br/>public class JavaClassTest {   // 主类<br/>	<br/>	public static void main (String[] args) {<br/>		Person person = new Person("李峰",67);<br/>		person.tell();<br/>	}<br/>} |

如果要想评价一个代码的好坏：

- ​	代码结构可以重用，提供的是一个中间独立的支持；

- ​    我们的目标是：没有重复；

对于本类构造方法的互相调用需要注意以下几点重要问题：.

- **构造方法必须在实例化新对象的时候调用，所以“this（）”的语句只允许放在构造方法的首行；**

- **构造方法互相调用时请保留有程序的出口，别形成死循环；**

```java
class Person {
	private String name;
	private int age;
	// 方法名称与类名相同，并且无返回值定义
	public Person() {
		this("你的眼",88);
		System.out.println("***一个新的Person类对象实例化。");
	}
	public Person(String name) {
		this();    //  调用本类无参构造
		this.name = name;
	}
	public Person(String name,int age) {
		this(name);    //  调用本类单参构造
		this.age = age;
	}
	public void tell() {
		System.out.println("姓名："+ this.name + "\n年龄：" + this.age);
	}
	// setter、getter略
}
public class JavaClassTest {   // 主类
	
	public static void main (String[] args) {
		Person person = new Person("李峰",67);
		person.tell();
	}
}
```

​		此时的程序在进行编译的时候将会直接出现错误提示：告诉用户，你出现了构造方法的递归调用。

**构造方法互调用案例：**

​		现在要求定义一个描述有员工信息的程序类，该类中提供有：编号、姓名、部门、工资，在这个类之中提供有四个构造方法。

1. 【无参构造】编号定义为1000，姓名定义为无名氏；
2. 【单参构造】传递编号，姓名定义为“新员工”，部门定义为“未定”，工资为0；
3. 【三参构造】传递编号、姓名、部门，工资为2500.00；
4. 【四参构造】所有的属性全部进行传递。.

**范例：**进行代码的初期实现

```java
class Emp{
	private long empno;    //  员工编号
	private String ename;  //  员工姓名
	private String dept;   //  部门名称
	private double salary; //  基本工资
	public Emp() {
		this.empno = 1000;
		this.ename = "无名氏";
	}
	public Emp(long empno) {
		this.empno = empno;
		this.ename = "未定";
	}
	public Emp(long empno,String ename,String dept) {
		this.empno = empno;
		this.ename = ename;
		this.dept  = dept;
		this.salary= 2500.00;
	}
	public Emp(long empno,String ename,String dept,double salary) {
		this.empno = empno;
		this.ename = ename;
		this.dept  = dept;
		this.salary= salary;
	}
	//setter、getter略
	public String getInfo() {
		return "雇员编号： " + this.empno + 
			   "\t雇员姓名： " + this.ename + 
			   "\t所在部门： " + this.dept  + 
			   "\t基本工资： " + this.salary;
	}
}
public class ConstructionMethod {

	public static void main(String[] args) {
		Emp emp = new Emp(9527L,"史密斯","财政部",6500.00);
		System.out.println(emp.getInfo());
	}
}
```

​		此时可以发现代码有重复，所以就可以对Emp类进行简化定义。

```java
class Emp{
	private long empno;    //  员工编号
	private String ename;  //  员工姓名
	private String dept;   //  部门名称
	private double salary; //  基本工资
	public Emp() {
		this(9527L,"无名氏",null,0.0);
	}
	public Emp(long empno) {
		this(empno,"未定",null,0.0);
	}
	public Emp(long empno,String ename,String dept) {
		this(empno,ename,dept,2500.00);
	}
	public Emp(long empno,String ename,String dept,double salary) {
		this.empno = empno;
		this.ename = ename;
		this.dept  = dept;
		this.salary= salary;
	}
	//setter、getter略
	public String getInfo() {
		return "雇员编号： " + this.empno + 
			   "\t雇员姓名： " + this.ename + 
			   "\t所在部门： " + this.dept  + 
			   "\t基本工资： " + this.salary;
	}
}
public class ConstructionMethod {

	public static void main(String[] args) {
		Emp emp = new Emp(9527L,"史密斯","财政部");
		System.out.println(emp.getInfo());
	}

}
```

​		代码的任何位置上都可能有重复，所以消除重复的代码是先期学习之中最需要考虑的。











































# 综合实战: 简单Java类

​		在以后进行项目的开发与设计的过程之中，简单Java类都将作为一个重要的组成部分存在，慢慢接触到正规的项目设计之后，简单Java类无处不在，并且有可能会产生一系列的变化。

​		所谓的简单java类指的是可以描述某一类信息的程序类，例如：描述一个人、描述一本书、描述一个部门、描述一个雇员。并且在这个类之中并没有特别复杂的逻辑操作，只作为一种信息存储的媒介存在。

​		对于简单Java类而言，其核心的开发结构如下：

- 类名称一定要有意义，可以明确的描述某一类事物；

- 类之中的所有属性都必须使用private进行封装，同时封装后的属性必须要提供有setter、getter方法；
- 类之中可以提供有无数多个构造方法，但是必须要保留有无参构造方法；

- 类之中不允许出现任何的输出语句，所有内容的获取必须返回；

- 【非必须】可以提供有一个获取对象详细信息的方法，暂时将此方法名称定义为getInfo（）；

**范例：**定义一个简单java类。

```java
class Dept{		// 类名称可以明确描述出某类事物
    private long deptno ;
    private String dname ; 
    private String loc ;
    public Dept(){};     // 必须提供有无参
    public Dept(long deptno,String dname,String loc){
        this.deptno = deptno;
        this.dname = dname;
        this.loc = loc;
    }
    public String getInfo(){
        return "【部门信息】部门编号：" + this.deptno + "、部门名称：" + this.dname + "、部门位置" + this.loc ; 
    }
    public void setDeptno(long deptno) {
        this.deptno = deptno;
    }
    public void setDname(String dname){
        this.dname = dname;
    }
    public void setLoc(String loc){
        this.loc = loc;
    }
    public void getDeptno(){
        return this.deptno;
    }
    public void getDname(){
        return this.dname;
    }
    public void getLoc(){
        return this.loc;
    }  
}
public class JavaClassTest01 {
	
	public static void main(String[] args) {
		Dept dept = new Dept(10,"技术部","北京");
		System.out.println(dept.getInfo());
	}
}
```

​		这种简单Java类基本上就融合了所有的现在接触到的概念，例如：数据类型划分、类的定义、private封装、构造方法、方法定义对象实例化。# 声明static属性

​		static是一个关键字，这个关键字主要可以用来定义属性和方法。下面将针对于此关键字分析。

**static定义属性**

在一个类之中，所有的属性一旦定义了实际上内容都交由各自的堆内存空间所保存。

**范例：**定义一个程序类,观察传统操作的问题

```java
class Person {  //  创建所有同一个国家的类
    private String name ;
    private int age ;
    String country = "中华民国" ;    //  国家， 暂时不封装
    public Person(String name,int age) {
        this.name = name;
        this.age = age;
    }
    // setter、getter略
    public String getInfo() {
        return "姓名：" + this.name + "、年龄" + this.age + "、国家: " + this.country;
    }
}
public class JavaClassTest02 {
	
	public static void main(String[] args) {
		Person perA = new Person("张三",10) ;
		Person perB = new Person("李四",10) ;
        Person perC = new Person("王五",11) ;
	    System.out.println(perA.getInfo());
	    System.out.println(perB.getInfo());
	    System.out.println(perC.getInfo());
	}
}

```

​		为了更好的观察出程序的问题，下面对此操作做一个内存的分析。![image-20210401094945012](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210401094945012.png)

​		在正常开发过程之中每一个对象要保存有各自的属性，所以此时的程序没有任何问题，但是如果突然有一天，国家解放了变为了中华人民共和国。 并且你已经产生了5000W个对象，那么此时面对你的将是场噩梦。因为每一个对象都拥有各自的country属性，所以这个时候就会发现从整体的设计上就出现了问题（重复保存数据并且修改不方便）。

​		那么这个时候最好的解决方案就是将country修改为公共属性，而这种情况下就必须使用static进行标注。

**范例：**修改Person类定义，使用static定义公共属性。

```java
   static String country = "中华民国" ;    //  在上面的程序之中，在country属性之前加上static，表明它是公共属性。
```

​		此时会发现所有对象中的country属性的内容都发生了改变，所以这是一个公共属性，而此时的内存关系图如下。

![image-20210401100334821](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210401100334821.png)

​		但是对于static属性的访问需要注意一点：由于其本身是一个公共的属性，虽然可以通过对象进行访问，但是最好的做法应该是通过所有对象的最高代表（类）来进行访问，所以static属性可以由类名称直接调用。

```java
Person.country = "中华人民共和国";
```

​		static属性虽然定义在类之中，但是其并不受到类实例化对象的控制。static属性可以在没有实例化对象的时候使用。

**范例：**不产生实例化对象调用static属性

```java
public class JavaClassTest02 {
	public static void main(String[] args) {
	    System.out.println(Person1.country);
	    Person1.country = "中华人民共和国" ;
	    Person1 per = new Person1("张三",10) ;
	    System.out.println(per.getInfo());
	}
}
```

​		在以后进行类设计的时候首选的一定是非static属性（95%），而考虑到公共信息存储的时候才会使用到static（5%）。非static属性必须在实例化对象产生之后才可以使用，而static属性可以在没有实例化对象产生的情况下直接通过类名称进行调用。# static 定义方法

​		static关键字也可以进行方法的定义，static方法的主要特点在于，其可以直接由类名称在没有实例化对象的情况下进行调用。

```java
class Person1 {  //  创建所有同一个国家的类
    private String name ;
    private int age ;
    private static String country = "中华民国" ;    //  国家， 暂时不封装
    public Person1(String name,int age) {
        this.name = name;
        this.age = age;
    }
    public static void setCountry(String c) {
		country = c;
	}
    // setter、getter略
    public String getInfo() {
        return "姓名：" + this.name + "、年龄：" + this.age + "、国家: " + this.country;
    }
}
public class JavaClassTest02 {
	
	public static void main(String[] args) {
		Person1.setCountry("中国人民共和国");
	    Person1 per = new Person1("张三",10) ;
	    System.out.println(per.getInfo());
	}
}

```

​		这个时候对于程序而言方法就有了两种：static方法、非static方法，这两个方法之间在调用上就有了限制。

- static 方法只允许调用static属性或static方法；

- 非static方法允许调用static属性或static方法；



​		  所有的static定义的属性和方法都可以在没有实例化对象的前提下使用，而所有的非static定义的属性和方法必须要有实例化对象的情况下才可以使用。

​		如果说现在可以理解这个限制，那么对于之前的方法定义就可以得出新的结论：在最早讲解方法定义的时候强调过：“当前定义的方法都是在主类中定义的，并且由主方法调用的”

| public class StaticUse {<br/><br/>	public static void main(String[] args) {<br/>		printdy();<br/><br/>	}<br/>	public **static** void printdy() {<br/>		System.out.println("张祥牛逼！！！！");<br/><br/>	}<br/><br/>} | public class StaticUse {<br/><br/>	public static void main(String[] args) {<br/>		new StaticUse().printdy();<br/><br/>	}<br/>	public void printdy() {<br/>		System.out.println("张祥牛逼！！！！");<br/><br/>	}<br/><br/>} |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
|                                                              |                                                              |

​		static 定义的方法或者是属性都不是你代码编写之初所需要考虑的内容，只有在回避实例化对象调用并且描述公共属性的情况下才会考虑使用static定义的方法或者是属性。

# **Static 应用**

​		为了加强理解，下面做两个简单的程序来进行static应用的提示。

**范例：**编写一个程序类，这个类可以实现实例化对象个数的统计，每一次创建新的实例化对象都可以实现一个统计操作。

- 此时可以单独创建一个 static属性，因为所有对象都共享同一个static属性，那么在构造方法中可以实现数据的统计处理。

```java
class Book{
	private String title ;
	private static int count = 0 ;
	public Book(String title) {
		this.title = title;
		count++;
		System.out.println("第" + count + 
			"本新的图书被创建出来。");
	}
}

public class JavaDemo{
	public static void main(String[] args){
		new Book("JSP");
		new Book("Jav");
		new Book("Js");
		new Book("JP");
	}
}
```

**范例：**实现属性的自动命名处理

- ​		如果现在传递了title属性，就使用传递的属性内容，而如果没有传递title属性，则自动采用“NOTITLF-编号”的形式进行该属性内容的定义。

```java
class Book{
	private String title ;
	private static int count = 0 ;
	public Book() {
		this("NOTITLF-" + count++);
	}
	public Book(String title) {
		this.title = title;
		
	}
	public String getTitle() {
		return this.title;
	}
}
public class JavaDemo{
	public static void main(String[] args){
		System.out.println(new Book("JSP").getTitle());
		System.out.println(new Book("时间简史").getTitle());
		System.out.println(new Book("埋雷").getTitle());
		System.out.println(new Book().getTitle());
		System.out.println(new Book().getTitle());
	}
}

```

​		这样处理的好处是可以避免在没有设置title属性时内容为null的重复问题。.# 代码块

​		在程序之中使用 “{ }” 定义的结构就称为代码块，而后根据代码块出现的位置以及定义的关键字的不同，代码块可以分为：普通代码块、构造块、静态块、同步代码块，其中对于同步代码块是在多线程的时候才会进行讲解。

## 普通代码块

​		普通代码块的主要特点是定义在一个方法之中的代码块。

**范例：观察一个程序**

```java
public class JavaDemo{
    public static void main(String[] args){
        if(true){ // 条件一定满足
            int x = 10;  // 局部变量
            System.out.println("x = " + x);
        }
        int x = 100;  //  全局变量
        System.out.println("x = " + x);
    }
}
```

​		按照Java程序的开发标准规定相同名称的变量是不能够在同一个方法之中存在的，但是由于此时有不同的分界描述。但如果说要定义普通代码块，那么只需要将当前的if语句取消即可。

```java
public class JavaDemo{
    public static void main(String[] args){
        { // 普通代码块
            int x = 10;  // 局部变量
            System.out.println("x = " + x);
        }
        int x = 100;  //  全局变量
        System.out.println("x = " + x);
    }
}
```

 		可以在一个方法之中进行一些结构的拆分，以防止相同变量名称所带来的互相影响。

## 构造代码块

​		 构造块是定义在一个类之中的

**范例：**观察构造块

```java
class Person01{
	public Person01() {
		System.out.println("【构造方法】Person类构造方法执行");
	}
	{
		System.out.println("【构造块】Person构造块执行");
	}
}

public class JavaDemo01 {

	public static void main(String[] args){
        new Person01();
        new Person01();
        new Person01();
    }

}
```

## 静态代码块

​		静态代码块主要指的是使用static关键字定义的代码块，静态块的定义需要考虑到两种情况：主类中定义静态块、非主类中定义静态块。

**范例：**在非主类中进行静态块的定义

```java
class Person01{
	public Person01() {
		System.out.println("【构造方法】Person类构造方法执行");
	}
	static{
		System.out.println("【静态块】静态块执行。");
		
	}
	{
		System.out.println("【构造块】Person构造块执行");
	}
}

public class JavaDemo01 {

	public static void main(String[] args){
        new Person01();
    }
}
```

​		此时可以发现静态代码块会优先于构造块执行，并且不管有多少个实例化对象出现静态代码块只会执行一次，静态代码块的主要目的是为类中的静态属性初始化。

**范例：**观察静态属性初始化



```java
class Message {
    public static String getCountry(){
        //该消息的内容可能来自于网络或者其他服务器
        return "中华人民共和国" ;
    }
}
class Person {
    private static String country ;
    static {
        // 可能有很多语句要执行
        country = Message.getCountry();
        System.out.println(country) ; 
    }
}
public class JavaDemo {
    public static void main(String arg[]){
        new Person();   
    }
}
```

​		对于静态代码块还必须考虑另一种情况，在主类中定义的形式。

**范例：**在主类中进行静态代码块的定义

```java
public class JavaDemo {
    static {
        System.out.println("******* 程序初始化 ********") ;
    }
    public static void main(String arg[]){
        System.out.println("主方法输出");
    }
}
```

​		静态代码块优先于主方法先执行。











































```java
package org.jgs.pratice;

public class Address {
	private String country;
	private String province;
	private String city;
	private String street;
	private String postcode;
	public Address () {}  // 无参构造
	public Address (String country,String province,String city,String street,String postcode) {
		this.country = country;												// 有参构造
		this.province = province;
		this.city = city;
		this.street = street;
		this.postcode = postcode;
	}
	public void setCountry(String country) {
		this.country = country;
	}
	public void setProvince(String province) {
		this.province = province;
	}
	public void setCity(String city) {
		this.city = city;
	}
	public void setStreet(String street) {
		this.street = street;
	}
	public void setPostcode(String postcode) {
		this.postcode = postcode;
	}
	public String getCountry() {
		return country;
	}
	public String getProvince() {
		return province;
	}
	public String getCity() {
		return city;
	}
	public String getStreet() {
		return street;
	}
	public String getPostcode() {
		return postcode;
	}
	public String getInfo() {
		
		return this.country + "" + this.province + "省" + this.city + "市" + this.street +
				"(街/道)" + this.postcode;

	}
	
}

```

#  案例分析二

​		定义并测试一个代表员工的Employee类。员工属性包括“编号”、“姓名”、“基本薪水”、“薪水增长率”，还包括计算薪水增长额及计算增长后的工资总额的操作方法。

​		这个程序的功能已经超过了简单Java类的定义范畴，因为简单Java类里面不需要涉及到复杂的计算逻辑，但是设计的思考是应该从简单java类开始。

```java

/**
 * @Description
 *  案例分析二
 * 		定义并测试一个代表员工的Employee类。员工
 * 属性包括“编号”、“姓名”、“基本薪水”、“薪水增长
 * 率”，还包括计算薪水增长额及计算增长后的工资总额
 * 的操作方法。
 * @author AlexYU Email:alex2354629991@gmail.com
 * @version
 * @date 2021年4月6日下午5:02:04
 */
public class Employee {
	private long code;
	private String name;	
	private double salary;
	private double rate;
	public Employee () {}
	public Employee (long code,String name,double salary,double rate) {
		this.code = code;
		this.name = name;
		this.salary = salary;
		this.rate = rate;
	}
	// 得到薪水增长额度
	public double salaryIncValue() {
		return this.salary * this.rate ;
	}
	// 计算薪水增长总额
	public double salaryIncResult() {
		
		this.salary = this.salary + this.salaryIncValue();
		
		return this.salary ;
	}
	public String getInfo() {
		return "编号:" + this.code + "、姓名:" + name + "、基本薪水:" + salary + "、薪水增长率:" + rate;
	// setter、getter略
	}
}

```

# 案例分析三

设计一个Dog类，有名字、颜色、年龄等属性，定义构造方法来初始化类的这些属性，定义构造方法来初始化类的这些属性，定义方法输出Dog信息，编写应用程序使用Dog类。

```java
/**
 * @Description
 * 		设计一个Dog类，有名字、颜色、年龄等属
 * 性，定义构造方法来初始化类的这些属性，定义构造方法
 * 来初始化类的这些属性，定义方法输出Dog信息，编写应用
 * 程序使用Dog类。
 * @author AlexYU Email:alex2354629991@gmail.com
 * @version
 * @date 2021年4月6日下午6:40:17
 */
public class Dog {
	private String name;
	private String color;
	private int age;
	public Dog() {}
	public Dog(String name,String color,int age) {
		this.age = age;
		this.name = name;
		this.color = color;
	}
	// setter、getter略
	public String getInfo() {
		return "名字是："+name+"\n毛色："+color+"\n年龄："+age;
	}
}

```

# 案例分析四

​		构造一个银行账户类，类的构成包括如下内容：

（1）、数据成员用户的账户名称、用户的账户余额（private数据类型）。
（2）、方法包括开户（设置账户名称及余额），利用构造方法完成。
（3）、查询余额。

```java
public class Account {
	private String name;
	private double balence;
	public Account() {}
	public Account(String name) {
		this(name,0.0);  // 调用双参构造
	}
	public Account(String name,double balence) {
		this.name = name;
		this.balence = balence;
	}
	public double getBalence() {
		return balence;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public void setBalence(double balence) {
		this.balence = balence;
	}
	public String getInfo() {
		return "账户名称：" + this.name + "\n账户余额：" + this.balence;

	}
}

```

# 案例分析五

​		设计一个表示用户的User类，类中的变量有用户名、口令和记录用户个数的变量，定义类的3个构造方法（无参、为用户名赋值、为用户名和口令赋值）、获取和设置口令的方法和返回类信息的方法。

```java
class User {
    private String uid;
    private String password;
    private static int count = 0;
    public User(){
        this("NOID","bdqn");
    }
    public User(String uid){
        this(uid,"jgs2111");
    }
    public User(Strong uid,String password){
        this.uid = uid;
        this.password = password;
        count ++ ; // 个数追加
    }
    // setter、getter略
    public static int getCount(){ //  获得用户个数
        return count;
        
    }
    public String getInfo() {
        return "用户名："+uid+"\n密码："+password;
    }
}
```

# 案例分析六

​		声明了个图书类，其数据成员为书名、编号（利用静态变量实现自动编号）、书价，并拥有静态数据成员册数、记录图书册数，在构造方法中利用此静态变量为对象的编号赋值，在主方法中定义多个对象，并求出总册数。

```java

/**
 * @Description 案例分析六
 * 声明了个图书类，其数据成员为书名、编号（利用静态变量实现自动编号）、
 * 书价，并拥有静态数据成员册数、记录图书册数，在构造方法中利
 * 用此静态变量为对象的编号赋值，在主方法中定义多个对象，并求出总册数。
 * @author AlexYU Email:alex2354629991@gmail.com
 * @version
 * @date 2021年4月6日下午7:40:25
 */
public class Book{
    private int bid;  // 编号
    private String title;  // 书名
    private static int count = 0;
    private double price;  // 价格
    public Book(String title,double price){
        this.bid = ++ count ;  // 先赋值再自增
        this.title = title;
        this.price = price;
    }
    // setter、getter略
    public String getInfo(){
        return "编号："+this.bid+"\t书名："+title+"\t价格："+price;
    }
    public static int getCount() {
    	return count;
    }
}
public class JavaDemo {
    
    public static void main(String arg[]){
    	Book b1 = new Book("javascript", 10.90);
    	Book b2 = new Book("java", 156.2220);
    	Book b3 = new Book("typescript", 18.90);
    	System.out.println(b1.getInfo());
    	System.out.println(b2.getInfo());
    	System.out.println(b3.getInfo());
    	System.out.println(Book.getCount());
    }
}
```

​		在面向对象最基础的开发里面，简单Java类是解决先期设计最好的方案。# 成员属性封装

​		在类之中的组成就是属性与方法，一般而言方法都是对外提供服务的，所以是不会进行封装处理的，而对于属性来说，由于其需要较高的安全性，所以往往需要对其进行保护，这个时候就需要采用封装性对其保护。

​		在默认的情况下，对于类中的属性是可以通过其他类利用对象进行调用的。

**范例：**属性不封装情况下的问题

```java
public class Class