# 引用传递与垃圾产生分析

​		经过了一系列的分析之后已经确认，所有的引用传递的本质就是一场堆内存的调戏游戏。

但是对于引用传递如果处理不当那么也会造成垃圾的产生，那么本次将针对于垃圾产生原因

进行简单分析。

范例：定义一个要分析的程序

```java
public static void main (String[] args) {
		Person per1 = new Person();//声明并实例化对象
		Person per2 = new Person();//声明并实例化对象
		per1.name = "张三";
		per1.age  = 23;
		per2.name = "李四";
		per2.age  = 26;
		
		per2 = per1;  // 引用传递
		per2.age = 80;
		per1.tell();//进行方法的调用
	}
```

此时明确的发生了引用传递，并且也成功的完成了引用传递的处理操作，但是下面来观察一下其

内存的分配与处理流程。

*一个栈内存只能够保存有一个堆内存的地址数据，如果发生更改，则之前的地址数据将从此栈内存中彻底消失。*

![image-20210329105503299](https://gitee.com/yu_chao_ping/typora/raw/master/images/image-20210329105503299.png)

​		所谓的垃圾空间指的就是没有任何栈内存所指向的堆内存空间，所有的垃圾将被GC（GarbageCollector、垃圾收集器）不定期进行回收并且释放无用内存空间，但是如果垃圾过多，一定将影响到GC的处理性能，从而降低整体的程序性能，那么在实际开发中，对于垃圾的产生越少越好。